
1.  Ans: e  
        6, 5, 2, 11, 7, 4, 9, 5, 2
        Postorder traversal order: LRN
        left subtree first, then right subtree, then current node

2.  Ans: d
        Postorder: LRN
        Preorder:  NLR
        Inorder:   LNR

3.  Ans: d
        AVL trees fix imbalances as soon as they occur to maintain
        a height of logn

4.  Ans: a
        Naive construction is O(n^2), but Ukkonen's algorithm has a 
        linear construction time complexity 

5.  Ans: b
        The highest priority value in a min heap always exists at
        the first index in the heap array. B is the only sequence
        where the highest priority element is at the first index

6.  Ans: a
        Quicksort's partition function works by first picking a pivot,
        which could be any element, then swapping values between the 
        left and right ends of the array until all values to the left 
        of the pivot are less than it and all values to the right are
        greater than it

7.  Ans: a (or c if the bubble sort is not adaptive)
        Adaptive variants of bubblesort will count the number of swaps
        made in each pass through the array. If there are no swaps, 
        the array is already sorted so bubblesort terminates on the 
        first pass through the array

8.  Ans: e
        a and b are swapped around
            - Hamiltonian paths/circuits include every VERTEX exactly once
            - Euler paths/circuits include every EDGE exactly once

9.  Ans: b
        A queue is used for BFS and a stack is used for DFS (or recursion)

10. Ans: d

        Stack S = newStack();   -> O(1)
        while (n > 0) {   
            push(S, n % 2);     -> O(1)
            n = n / 2;          -> O(1)
        }

        Because in each loop n is reduced by half, the loop terminates after
        log2(n) loops.   

