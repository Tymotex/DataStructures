<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>COMP2521 - Data Structures and Algorithms</title><style>
/* webkit printing magic: print all background colors */
html {
    -webkit-print-color-adjust: exact;
}
* {
    box-sizing: border-box;
    -webkit-print-color-adjust: exact;
}

html,
body {
    margin: 0;
    padding: 0;
}
@media only screen {
    body {
        margin: 2em auto;
        max-width: 900px;
        color: rgb(55, 53, 47);
    }
}

body {
    line-height: 1.5;
    white-space: pre-wrap;
}

a,
a.visited {
    color: inherit;
    text-decoration: underline;
}

.pdf-relative-link-path {
    font-size: 80%;
    color: #444;
}

h1,
h2,
h3 {
    letter-spacing: -0.01em;
    line-height: 1.2;
    font-weight: 600;
    margin-bottom: 0;
}

.page-title {
    font-size: 2.5rem;
    font-weight: 700;
    margin-top: 0;
    margin-bottom: 0.75em;
}

h1 {
    font-size: 1.875rem;
    margin-top: 1.875rem;
}

h2 {
    font-size: 1.5rem;
    margin-top: 1.5rem;
}

h3 {
    font-size: 1.25rem;
    margin-top: 1.25rem;
}

.source {
    border: 1px solid #ddd;
    border-radius: 3px;
    padding: 1.5em;
    word-break: break-all;
}

.callout {
    border-radius: 3px;
    padding: 1rem;
}

figure {
    margin: 1.25em 0;
    page-break-inside: avoid;
}

figcaption {
    opacity: 0.5;
    font-size: 85%;
    margin-top: 0.5em;
}

mark {
    background-color: transparent;
}

.indented {
    padding-left: 1.5em;
}

hr {
    background: transparent;
    display: block;
    width: 100%;
    height: 1px;
    visibility: visible;
    border: none;
    border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
    max-width: 100%;
}

@media only print {
    img {
        max-height: 100vh;
        object-fit: contain;
    }
}

@page {
    margin: 1in;
}

.collection-content {
    font-size: 0.875rem;
}

.column-list {
    display: flex;
    justify-content: space-between;
}

.column {
    padding: 0 1em;
}

.column:first-child {
    padding-left: 0;
}

.column:last-child {
    padding-right: 0;
}

.table_of_contents-item {
    display: block;
    font-size: 0.875rem;
    line-height: 1.3;
    padding: 0.125rem;
}

.table_of_contents-indent-1 {
    margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
    margin-left: 3rem;
}

.table_of_contents-indent-3 {
    margin-left: 4.5rem;
}

.table_of_contents-link {
    text-decoration: none;
    opacity: 0.7;
    border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
    border: 1px solid rgba(55, 53, 47, 0.09);
    border-collapse: collapse;
}

table {
    border-left: none;
    border-right: none;
}

th,
td {
    font-weight: normal;
    padding: 0.25em 0.5em;
    line-height: 1.5;
    min-height: 1.5em;
    text-align: left;
}

th {
    color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
    margin: 0;
    margin-block-start: 0.6em;
    margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
    margin-block-start: 0.6em;
}

ul > li {
    list-style: disc;
}

ul.to-do-list {
    text-indent: -1.7em;
}

ul.to-do-list > li {
    list-style: none;
}

.to-do-children-checked {
    text-decoration: line-through;
    opacity: 0.375;
}

ul.toggle > li {
    list-style: none;
}

ul {
    padding-inline-start: 1.7em;
}

ul > li {
    padding-left: 0.1em;
}

ol {
    padding-inline-start: 1.6em;
}

ol > li {
    padding-left: 0.2em;
}

.mono ol {
    padding-inline-start: 2em;
}

.mono ol > li {
    text-indent: -0.4em;
}

.toggle {
    padding-inline-start: 0em;
    list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
    padding-left: 1.7em;
}

.toggle > li > details > summary {
    margin-left: -1.1em;
}

.selected-value {
    display: inline-block;
    padding: 0 0.5em;
    background: rgba(206, 205, 202, 0.5);
    border-radius: 3px;
    margin-right: 0.5em;
    margin-top: 0.3em;
    margin-bottom: 0.3em;
    white-space: nowrap;
}

.collection-title {
    display: inline-block;
    margin-right: 1em;
}

time {
    opacity: 0.5;
}

.icon {
    display: inline-block;
    max-width: 1.2em;
    max-height: 1.2em;
    text-decoration: none;
    vertical-align: text-bottom;
    margin-right: 0.5em;
}

img.icon {
    border-radius: 3px;
}

.user-icon {
    width: 1.5em;
    height: 1.5em;
    border-radius: 100%;
    margin-right: 0.5rem;
}

.user-icon-inner {
    font-size: 0.8em;
}

.text-icon {
    border: 1px solid #000;
    text-align: center;
}

.page-cover-image {
    display: block;
    object-fit: cover;
    width: 100%;
    height: 30vh;
}

.page-header-icon {
    font-size: 3rem;
    margin-bottom: 1rem;
}

.page-header-icon-with-cover {
    margin-top: -0.72em;
    margin-left: 0.07em;
}

.page-header-icon img {
    border-radius: 3px;
}

.link-to-page {
    margin: 1em 0;
    padding: 0;
    border: none;
    font-weight: 500;
}

p > .user {
    opacity: 0.5;
}

td > .user,
td > time {
    white-space: nowrap;
}

input[type="checkbox"] {
    transform: scale(1.5);
    margin-right: 0.6em;
    vertical-align: middle;
}

p {
    margin-top: 0.5em;
    margin-bottom: 0.5em;
}

.image {
    border: none;
    margin: 1.5em 0;
    padding: 0;
    border-radius: 0;
    text-align: center;
}

.code,
code {
    background: rgba(135, 131, 120, 0.15);
    border-radius: 3px;
    padding: 0.2em 0.4em;
    border-radius: 3px;
    font-size: 85%;
    tab-size: 2;
}

code {
    color: #eb5757;
}

.code {
    padding: 1.5em 1em;
}

.code-wrap {
    white-space: pre-wrap;
    word-break: break-all;
}

.code > code {
    background: none;
    padding: 0;
    font-size: 100%;
    color: inherit;
}

blockquote {
    font-size: 1.25em;
    margin: 1em 0;
    padding-left: 1em;
    border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
    text-decoration: none;
    max-height: 8em;
    padding: 0;
    display: flex;
    width: 100%;
    align-items: stretch;
}

.bookmark-title {
    font-size: 0.85em;
    overflow: hidden;
    text-overflow: ellipsis;
    height: 1.75em;
    white-space: nowrap;
}

.bookmark-text {
    display: flex;
    flex-direction: column;
}

.bookmark-info {
    flex: 4 1 180px;
    padding: 12px 14px 14px;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
}

.bookmark-image {
    width: 33%;
    flex: 1 1 180px;
    display: block;
    position: relative;
    object-fit: cover;
    border-radius: 1px;
}

.bookmark-description {
    color: rgba(55, 53, 47, 0.6);
    font-size: 0.75em;
    overflow: hidden;
    max-height: 4.5em;
    word-break: break-word;
}

.bookmark-href {
    font-size: 0.75em;
    margin-top: 0.25em;
}

.sans { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.highlight-default {
}
.highlight-gray {
    color: rgb(155,154,151);
}
.highlight-brown {
    color: rgb(100,71,58);
}
.highlight-orange {
    color: rgb(217,115,13);
}
.highlight-yellow {
    color: rgb(223,171,1);
}
.highlight-teal {
    color: rgb(15,123,108);
}
.highlight-blue {
    color: rgb(11,110,153);
}
.highlight-purple {
    color: rgb(105,64,165);
}
.highlight-pink {
    color: rgb(173,26,114);
}
.highlight-red {
    color: rgb(224,62,62);
}
.highlight-gray_background {
    background: rgb(235,236,237);
}
.highlight-brown_background {
    background: rgb(233,229,227);
}
.highlight-orange_background {
    background: rgb(250,235,221);
}
.highlight-yellow_background {
    background: rgb(251,243,219);
}
.highlight-teal_background {
    background: rgb(221,237,234);
}
.highlight-blue_background {
    background: rgb(221,235,241);
}
.highlight-purple_background {
    background: rgb(234,228,242);
}
.highlight-pink_background {
    background: rgb(244,223,235);
}
.highlight-red_background {
    background: rgb(251,228,228);
}
.block-color-default {
    color: inherit;
    fill: inherit;
}
.block-color-gray {
    color: rgba(55, 53, 47, 0.6);
    fill: rgba(55, 53, 47, 0.6);
}
.block-color-brown {
    color: rgb(100,71,58);
    fill: rgb(100,71,58);
}
.block-color-orange {
    color: rgb(217,115,13);
    fill: rgb(217,115,13);
}
.block-color-yellow {
    color: rgb(223,171,1);
    fill: rgb(223,171,1);
}
.block-color-teal {
    color: rgb(15,123,108);
    fill: rgb(15,123,108);
}
.block-color-blue {
    color: rgb(11,110,153);
    fill: rgb(11,110,153);
}
.block-color-purple {
    color: rgb(105,64,165);
    fill: rgb(105,64,165);
}
.block-color-pink {
    color: rgb(173,26,114);
    fill: rgb(173,26,114);
}
.block-color-red {
    color: rgb(224,62,62);
    fill: rgb(224,62,62);
}
.block-color-gray_background {
    background: rgb(235,236,237);
}
.block-color-brown_background {
    background: rgb(233,229,227);
}
.block-color-orange_background {
    background: rgb(250,235,221);
}
.block-color-yellow_background {
    background: rgb(251,243,219);
}
.block-color-teal_background {
    background: rgb(221,237,234);
}
.block-color-blue_background {
    background: rgb(221,235,241);
}
.block-color-purple_background {
    background: rgb(234,228,242);
}
.block-color-pink_background {
    background: rgb(244,223,235);
}
.block-color-red_background {
    background: rgb(251,228,228);
}
.select-value-color-default { background-color: rgba(206,205,202,0.5); }
.select-value-color-gray { background-color: rgba(155,154,151, 0.4); }
.select-value-color-brown { background-color: rgba(140,46,0,0.2); }
.select-value-color-orange { background-color: rgba(245,93,0,0.2); }
.select-value-color-yellow { background-color: rgba(233,168,0,0.2); }
.select-value-color-green { background-color: rgba(0,135,107,0.2); }
.select-value-color-blue { background-color: rgba(0,120,223,0.2); }
.select-value-color-purple { background-color: rgba(103,36,222,0.2); }
.select-value-color-pink { background-color: rgba(221,0,129,0.2); }
.select-value-color-red { background-color: rgba(255,0,26,0.2); }

.checkbox {
    display: inline-flex;
    vertical-align: text-bottom;
    width: 16;
    height: 16;
    background-size: 16px;
    margin-left: 2px;
    margin-right: 5px;
}

.checkbox-on {
    background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
    background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
    
</style></head><body><article id="708288ca-10b5-41e5-b21b-d26a1179f52b" class="page sans"><header><img class="page-cover-image" src="https://images.unsplash.com/photo-1555099962-4199c345e5dd?ixlib=rb-1.2.1&amp;q=85&amp;fm=jpg&amp;crop=entropy&amp;cs=srgb" style="object-position:center 38.800000000000004%"/><div class="page-header-icon page-header-icon-with-cover"><span class="icon">⚙</span></div><h1 class="page-title">COMP2521 - Data Structures and Algorithms</h1></header><div class="page-body"><nav id="f340b58c-73bb-4d70-9ca6-9b100fa293e0" class="block-color-gray table_of_contents"><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#3f635b08-1602-49eb-ba8b-cff6102e0999">Week 1: Algorithm Analysis </a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#1f91d294-6e4e-4047-b8dd-c135ab6d5b76">Algorithm Analysis:</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#a62c3720-d95a-4b2d-a18c-4899d7d67d84">Big-O Notation (Time Complexity): </a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#6bb71823-6328-40b5-b620-1830b82ea71b">Week 2: Compilation and ADTs</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#8d2bd57d-09c8-474c-92bb-e9361da9519e">Abstract Data Types:</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#8ea6d8fa-a02f-4ba7-9276-431b425eca3b">Week 3: Trees I</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#476f0d33-4518-49c0-9ebb-c6830fb95e8b">Tree Data Structures:</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#082784b6-1a3c-4fd8-98ff-8a3729255a33">Binary Search-Trees:</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#e62c2eb4-391c-45af-9265-fd83340b96da"><strong>Tree Algorithms: </strong></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#9b69aeb2-d622-4d7e-bd42-5ed80ee06a1e"><strong>Tree traversal:</strong></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#7dda2482-18fb-4fc0-b501-318b808053b6">T<strong>ree Properties:</strong></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#877c2bdc-0b14-415b-90d4-dc816ec98034"><strong>Tree Maintenance:</strong></a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#cd10eb54-a018-445d-8ecd-cbd3e17c3a35">Week 4: Trees II — Specialised Search Trees</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#7a8c0e7c-af14-4a6c-b78f-134cb096c805"><strong>Splay Trees:</strong></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#205633f9-5077-4d78-bc7a-812075523194">AVL-Trees:</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#7a7041b0-a1b3-47c9-8517-0c14a9a8b7c0">2-3-4 Trees: </a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#0c4177d4-364a-45bc-98e4-4369a347eb9a">Week 5: Graphs I</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#fbe61718-6a8e-4c74-9812-20ca62a54eee">Graph Data Structures</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#404de8ac-580b-48cb-9512-5071b4b8770f">Graph <strong>Algorithms: </strong></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#53de2a61-0153-417b-86ba-4be40dfcf2b7">Graph Traversal: </a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#8808b592-75b2-4acf-9da9-616b47de673e">Graph Properties: </a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#8ab1dd7e-e047-4300-a30c-a170cd58be04">Week 6: Graphs II</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#5ad7ad87-f299-4cfb-aa67-8fc973a1c40c">More on Graph Representation:</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#2e2a8c31-ac7d-43cf-948d-21a6cd8958e8">Directed Graphs:</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#17faa547-92cd-4add-a880-1e89fb2a4216">Weighted Graphs:</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#0b9b6fa5-0ca1-4c6c-a31e-e3e4a8209100">Graph Spanning Tree Algorithms:</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#e71066e2-7249-4a94-a21f-111fcea411ac">Week 7: Heaps and Hashing</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#bce3caa6-7ebe-4a72-84cb-8627a3802a70">Heaps:</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#70dfc310-6c78-4fb1-8562-984595b9a12b">Hashing:</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#f92d6d65-ac83-45b4-9d97-14f7c197b880">Week 8: Sorting Algorithms</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#7e69ac5a-0f69-4323-b078-521a0d596449">Sorting:</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#e539d6b5-5412-48f1-8f5a-28cf0a29abad">Comparison Sorting Algorithms:</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#e8737ca4-da54-408d-ba2c-768639a7f041">Non-Comparison based sorting</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#8e6c9907-ad63-4b64-9ad1-ff1ac13a6171">Week 9: Text Processing Algorithms</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#ec801f3a-8f8e-4b65-9cff-c52025c6130e">Boyer-Moore Algorithm: </a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#2493184c-3cad-4736-91cf-495cb82875cb">Knuth-Morris-Pratt Algorithm:</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#61787c18-0b5f-4174-8ad8-3f5af42d75a7">Tries:</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#fe2da8bd-2a4c-4606-a0e2-2103c4d31a39">Compressed Tries:</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#bf7e854a-b8fc-4dbb-8500-123ab1304d5b"><strong>Text Compression — Huffman&#x27;s Algorithm:</strong></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#aeed0b6e-1dd7-4951-b291-7fa170fea677">C Extras: </a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#9166c833-6fdc-4243-b74e-e092781e75b0">Compilation and Makefiles:</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#6c08d869-a7aa-4fc4-97b1-bd57fa710740">Function Pointers:</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#c514b580-49e4-44b8-97d0-e785813f9a25">Generic Types:</a></div></nav><h1 id="3f635b08-1602-49eb-ba8b-cff6102e0999" class="block-color-blue_background">Week 1: Algorithm Analysis </h1><h3 id="1f91d294-6e4e-4047-b8dd-c135ab6d5b76" class="block-color-teal_background">Algorithm Analysis:</h3><p id="7e6104b9-721b-473a-9fd7-5a92e5ab937b" class=""><strong>Terminology:</strong></p><ul id="08a8c3fa-4418-49ed-bf06-66bde7def68f" class="bulleted-list"><li><em>Empirical analysis —</em> involves implementing and running the algorithm and plotting a graph of time taken vs. input size</li></ul><ul id="112be3d1-4f78-43f6-9bda-faa0560cb306" class="bulleted-list"><li><em>Theoretical analysis</em> — involves determining running time as a <em>function</em> of input size, <em>n</em>.
*independent of hardware and programming language (we can analyse <em>pseudocode </em>in terms of the number of <em>primitive operations</em> — maximised in the worst case)</li></ul><ul id="f0e70a51-8739-4c2d-b5d5-b5d663e26728" class="bulleted-list"><li><em>Primitive operations</em> — accessing an array index, calling functions, evaluating expressions, etc.</li></ul><div id="8ca047a3-69f9-4850-84a6-0f6866f2f14d" class="column-list"><div id="ff742c47-8210-4bf4-9809-2a5a50bd6b9f" style="width:56.25%" class="column"><h3 id="a62c3720-d95a-4b2d-a18c-4899d7d67d84" class="block-color-teal_background">Big-O Notation (Time Complexity): </h3><ul id="908ddc17-656a-4c1a-9652-f9584881e3d0" class="bulleted-list"><li>Formal definition: if there exists positive constants <em>c</em> and <em>b</em> such that <em>f(n) ≤ cg(n)</em> holds for all <em>n &gt; b</em>, then <em>f(n)</em> is <em>O(g(n))</em><figure id="4a565ff3-c09b-448f-af2d-a42cbfeee177" class="image"><a href="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled.png"><img style="width:336px" src="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled.png"/></a></figure></li></ul><ul id="73466f8b-897e-4524-9f52-ddb7b91bc94d" class="bulleted-list"><li>It is true that <em>&quot;2n is O(n²)&quot;</em>, however we want the smallest class of functions, so we say <em>&quot;2n is O(n)&quot;</em></li></ul><ul id="ef98180e-9f97-4658-ae73-7e85f849f49b" class="bulleted-list"><li>Big <em>O</em> — upper limit (worst case)   <em>f(n) ≤ cg(n)</em>
Big <em>Θ</em> — average range                  <em>f(n) ≥ cg(n)</em>
Big <em>Ω</em> — lower limit (best case)     <em>c&#x27;g(b) ≤ f(n) ≤ c&#x27;&#x27;g(n) 
</em>The worst case time-complexity is generally the most important to discuss</li></ul><ul id="27e6231e-0070-4ad6-9f2a-8bdb42f2c48e" class="bulleted-list"><li>Polynomials: for <em>f(n)</em> with degree <em>d</em>, f(n) is <em>O(nᵈ)</em></li></ul><ul id="f1dd2b34-397e-4c29-a953-48eab58ab75f" class="bulleted-list"><li>For finding the worst case in recursive algorithms, we must understand the logic and work out how many steps are taken to reach the base case </li></ul><ul id="67822bfb-5d9c-410b-83e0-9d8e90b4c096" class="bulleted-list"><li><strong>Complexity classes:</strong><em>
N — </em>problems computable in polynomial time<em>
NP — </em>problems only computable in exponential time, so no P algorithm is known (&quot;non-deterministic polynomial time on a theoretical <em>Turing Machine</em>&quot;)
<em>&quot;tractable&quot;</em> — has a polynomial-time algorithm <em>
&quot;intractable&quot;</em> — only exponential-time algorithms are known  
*It has been proved that if some NP class problem can be solved in polynomial time, then ALL NP class problems become P problems</li></ul><ul id="e64bfde4-3c14-4575-b637-e701c73bd977" class="bulleted-list"><li><strong><em>Generate and test </em></strong><strong>algorithms:</strong>
Useful when it is simple to generate new states and test whether they are a solution.
This guarantees we either find a solution, or prove none exist.
Eg. Checking primality by generating 2 to n-1 numbers and testing them</li></ul><ul id="c2520189-2a19-47b0-a72e-1a12f5c68f45" class="bulleted-list"><li>Big-O is less about the exact number of operations and more about how the number changes with respect to problem size. A function with O(1) complexity (constant time) could take 0.000001 seconds to execute or two weeks to execute.</li></ul></div><div id="60bce9ea-0454-4af4-a2c6-7b8da0bb5340" style="width:43.75%" class="column"><p id="7e5e929e-f085-4732-8edb-ae52fb8d3a32" class=""><em>Time-complexity for different operations on common data structures:</em></p><figure id="1e9e976a-198f-497b-9fe7-62c199d4b36a" class="image"><a href="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%201.png"><img style="width:720px" src="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%201.png"/></a></figure><p id="33e6646b-0679-4451-8812-88cff42a2aeb" class="">
</p></div></div><hr id="5bfac1a6-1c02-4a68-8449-5c9c0c41ce11"/><div id="83dbbd2a-b602-42e1-8075-3c670883b720" class="column-list"><div id="331731be-2d31-452f-ad73-8e2a3d2b04d1" style="width:25%" class="column"><p id="5fb2f7dd-6fb0-4844-93b2-d5cc17b90618" class=""><strong>Examples:
</strong>O(1)</p><pre id="29c892cf-bdad-4af1-bb29-476cbe704fb9" class="code"><code>void swap(int a[], int i, int j) {
        int tmp = a[i];  // O(1)
        a[i] = a[j];     // O(1)
        a[j] = tmp;      // O(1)
}                    // Total: O(1)</code></pre></div><div id="028ffd9e-0c9c-4837-8e48-35a3eef6c8c7" style="width:25%" class="column"><p id="d4847eab-2cff-43bc-82a8-a133ead41f8e" class="">
O(n)</p><pre id="27c3fbf9-9155-4c74-bc5e-429db4d5f54a" class="code"><code>for (int i = 0; i &lt; n; i++) {
        // Some O(1) statements
}   // Total: O(n)</code></pre></div><div id="01fad962-07d3-4adc-bb7e-7f868e336c10" style="width:25%" class="column"><p id="3338ad19-2f72-4c45-be6a-190c529bd00e" class="">
O(n²)</p><pre id="e4c43e99-c171-45de-a070-daa745cc0161" class="code"><code>for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; n; j++) {
                // Some O(1) statements
        }
}   // Total: O(n²), basically counting how many times the innermost statements get executed</code></pre></div><div id="40bdc1c2-910d-4103-b332-25f2d6dc5174" style="width:25%" class="column"><p id="68e500f3-5491-4a34-a9bc-5c83919672f8" class="">
O(logn)</p><pre id="f986c842-84c2-42e0-8691-676a29b21fa6" class="code"><code>for (int i = 0; i &lt; n; i *= 2) {
        // Some O(1) statements
}   // Total: O(log₂n)
// Eg. for n = 100, the loop will execute log₂(100) times, which is 6 or 7 times</code></pre></div></div><h1 id="6bb71823-6328-40b5-b620-1830b82ea71b" class="block-color-blue_background">Week 2: Compilation and ADTs</h1><h3 id="8d2bd57d-09c8-474c-92bb-e9361da9519e" class="block-color-teal_background">Abstract Data Types:</h3><ul id="f9b0d0a2-429c-44e4-87eb-96b7914bdf51" class="bulleted-list"><li><strong>Abstract data type: </strong>
Abstract data types provide a separation between the interface and implementation. The interface only presents high-level functions that can be performed and their pre-conditions and post-conditions without us being concerned with how they are implemented. Users of the ADT see and use only the interface, so they are completely unaware of the underlying implementation of it.</li></ul><ul id="9d82c98a-c3d8-4729-b682-39e22bfec266" class="bulleted-list"><li>The interface (header file) provides just the function signatures/prototypes and a description of their semantics </li></ul><ul id="720a93f6-2d52-4888-a02e-4c204edb33ea" class="bulleted-list"><li><strong>Collections:</strong>
Many ADTs are a collection of items, which might be simple types with an associated key. <ul id="55e3651e-e957-4a1b-bf8c-37bbc93a14d0" class="bulleted-list"><li>Collections are categorised in terms of structure: <em>linear, branching, cyclic</em>, or in terms of usage: <em>set, matrix, stack, queue, search-tree, dictionary</em></li></ul><ul id="099e258a-39c6-47d0-84b7-3e320d67aa87" class="bulleted-list"><li>Typical functions: <em>create(), insert(), remove(), find(), display(),</em> etc.</li></ul></li></ul><hr id="cb1443e7-d224-4856-94a4-58b845e1db3c"/><div id="6ec2eff4-6b02-4b2d-bdbe-1d2069d24657" class="column-list"><div id="aa0a9f3f-240d-4a21-8a65-f0814cba280c" style="width:50%" class="column"><p id="2f668a49-3e10-4123-b5f9-33fe75fd60a1" class=""><strong>Set ADT example:
</strong>A typical abstract <strong>set</strong> data type requires the following functions:</p><ul id="faf6adb8-21c3-42f4-b073-6157d61a321d" class="bulleted-list"><li><code>Set newSet()</code></li></ul><ul id="cebd7da3-f2f2-4b7b-948f-7383b511fc03" class="bulleted-list"><li><code>void freeSet(Set s)</code></li></ul><ul id="ff576081-adc0-4eda-9b4a-baf9c3ebb4ec" class="bulleted-list"><li><code>void displaySet(Set s)</code></li></ul><ul id="812f8530-1c5e-4b15-8dd2-2e2010721eee" class="bulleted-list"><li><code>void setInsert(Set s, int data)</code></li></ul><ul id="4c69d4b2-ea20-4fca-b9bf-53e7d2973a79" class="bulleted-list"><li><code>void setRemove(Set s, int target)</code></li></ul><ul id="ce2db7cb-cdeb-4f05-9f7b-e2614f8f1ae4" class="bulleted-list"><li><code>bool setIsMember(Set s, int target)</code></li></ul><ul id="b40ecd6f-1fc4-4906-b0c7-6ef0de45df8e" class="bulleted-list"><li><code>Set setUnion(Set s, Set t)</code></li></ul><ul id="a202bbdd-2858-4f34-90d7-f969afc3d751" class="bulleted-list"><li><code>Set setIntersection(Set s, Set t)</code></li></ul><ul id="552364c2-6323-4011-afc1-a070fd9c1ee1" class="bulleted-list"><li><code>int setCardinality(Set s)</code></li></ul><p id="299ee1f7-b043-434e-b71e-245e45f25bc7" class="">ADTs are also expected to implement error-handling to check that things like pre-conditions, post-conditions and whether or not the input is valid value.</p></div><div id="dc41c728-741f-4c91-94ff-4d4e468fcaf2" style="width:50%" class="column"><p id="678dac6d-2841-43d0-b806-d2ae99f406a7" class=""><em>Time-complexities for a set implementation using various underlying data structures:</em></p><figure id="39f1d5b1-210b-4a81-abb1-60536b05f74a" class="image"><a href="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%202.png"><img style="width:576px" src="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%202.png"/></a></figure><p id="42bfcc1c-092b-4f40-914a-b8f9cd62baab" class="">As the person implementing an abstract data type for other uses, after you decide what functions you want to supply, you go through each possible implementation and compare the set of time-complexities for each implementation and then pick the appropriate implementation based on which functions are most important to the specifications. </p></div></div><hr id="5308a575-0905-42d8-b35e-bcc29d93d1f1"/><h1 id="8ea6d8fa-a02f-4ba7-9276-431b425eca3b" class="block-color-blue_background">Week 3: Trees I</h1><div id="42b4dae4-fa6d-4949-8696-eefb65d8b0aa" class="column-list"><div id="ad51a87e-6846-42c7-994a-bcec09cce565" style="width:54.166666666666664%" class="column"><h3 id="476f0d33-4518-49c0-9ebb-c6830fb95e8b" class="">Tree Data Structures:</h3><ul id="91e03cc1-3147-45b4-96c6-48913bfcc82b" class="bulleted-list"><li>Trees — connected graphs with no cycles where any two nodes are connected by exactly one unique path. Each node holds data and has links to child nodes</li></ul><ul id="e37097bd-2433-4d0f-9c79-c27cd8ae86f7" class="bulleted-list"><li>Binary trees — recursive definition: &quot;a binary tree is a tree that is either empty, or consists of a node with two binary subtrees&quot;<ul id="98e41f31-7d3e-4f73-8750-e670c367b68a" class="bulleted-list"><li>Binary search trees — every node is the <em>root </em>of 0-2 <em>subtrees,</em> where the left subtree contains all values lower than the root value and right subtree contains all values greater than the root value</li></ul></li></ul><ul id="b0d9359c-4f0f-4195-8c95-5b7d2f149ffa" class="bulleted-list"><li>Balanced tree — has <em>minimal </em>height possible for the given number of nodes (for n nodes, the height is <em>log(n)</em>)<ul id="a1d5049f-7662-46a8-adaf-22378d486926" class="bulleted-list"><li>Perfectly balanced tree —  when the difference between the number of nodes in the subtrees of <em>every node</em> is no more than 1
<code>abs(countNodes(t → left), countNodes(t → right)) ≤ 1</code></li></ul></li></ul><ul id="c011b821-530f-4bc5-b6bf-922fd6345426" class="bulleted-list"><li>Degenerate tree — has<em> maximal </em>height possible for the given number of nodes (linear structure)</li></ul></div><div id="227a2eb7-b11a-4482-83b7-5181a4087284" style="width:20.833333333333332%" class="column"><p id="9467acdf-2fcd-47f4-b4ca-c9f8ab736bbc" class=""><em>Tree structure:</em></p><figure id="73529fb8-549e-4b3c-990d-dc77c2814832" class="image"><a href="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%203.png"><img style="width:288px" src="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%203.png"/></a></figure><figure id="48740203-e129-4a5d-982b-4d8c580aa975" class="image"><a href="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%204.png"><img style="width:336px" src="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%204.png"/></a></figure></div><div id="c5b6faad-17d9-465a-8180-259fa38f4ff1" style="width:25.000000000000018%" class="column"><p id="7ef21ef4-f550-4a8e-9255-3e7113602623" class=""><em>Tree &#x27;indexes&#x27;:</em></p><figure id="2ffed17c-f7e9-46d4-80d8-6be85c53365d" class="image"><a href="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%205.png"><img style="width:336px" src="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%205.png"/></a></figure></div></div><div id="2a130939-70dd-4afd-9c6d-692ad2c3ce2f" class="column-list"><div id="79277795-4e11-41b3-b36b-473485c0f4d6" style="width:50%" class="column"><h3 id="082784b6-1a3c-4fd8-98ff-8a3729255a33" class="">Binary Search-Trees:</h3><ul id="21b8273a-be3c-47db-a8f4-4db059f86f86" class="bulleted-list"><li>The time-complexity for tree algorithms is typically <em>O(height of tree),</em> and for a <em>balanced </em>binary search tree, <em>height = log(n)</em>.</li></ul><ul id="9f132579-6af5-411c-80dd-3e2a64ab9ef9" class="bulleted-list"><li>Example: consider the <em>balanced binary search tree </em>corresponding to the sorted array: [2, 5, 10, 12, 14, 17, <strong>20</strong>, 24, 29, 30, 31, 32]<ul id="a9ba4383-d25f-451c-a6c9-f49821769945" class="bulleted-list"><li>All child nodes to the left are less than the parent, all child nodes to the right are greater than the parent.- </li></ul><ul id="91594075-f2b7-4e79-905a-c12612920523" class="bulleted-list"><li>Every node has <em>at most 2 child nodes</em></li></ul><ul id="fe7226f8-c01d-4a29-a122-3d4514dcbad2" class="bulleted-list"><li>If the target value isn&#x27;t found in the tree, then it is inserted where it was failed to be found. </li></ul></li></ul><ul id="688c989e-7d13-44fe-903c-a13c40c722e4" class="bulleted-list"><li>The structure of the tree depends on the order of insertion of the elements</li></ul><ul id="b7aff8fe-1d4d-4853-a827-b47e768f1d8c" class="bulleted-list"><li>Each node contains a pointer to the root node of its left subtree and a pointer to the root node of its right subtree</li></ul></div><div id="814400fe-c2d8-4b79-9930-8f2fe520bb69" style="width:50%" class="column"><p id="49904b84-8fb0-436a-af6b-cb5cdfd6d02c" class=""><em>Possible struct declaration:</em></p><pre id="9911c29e-91ef-44cd-b828-ed4083c70326" class="code"><code>typedef struct BSTNode *Tree;
struct BSTNode {  
        int data;
        BSTNode *left;
        BSTNode *right;   // We could add more fields like: int numNodes, which counts how many nodes are under this node
};</code></pre><p id="367e2099-5a73-4ac4-ab26-0e332449855f" class="">
</p></div></div><div id="7c298d38-cfc6-40a1-9f0e-144b6fcb62d8" class="column-list"><div id="9872a8d2-57d7-4973-9bc8-53ba7bfd4b2d" style="width:25%" class="column"><figure id="9c61c4ea-2021-46e8-9980-656d96f0c303" class="image"><a href="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%206.png"><img style="width:384px" src="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%206.png"/></a></figure></div><div id="cf69a350-0e06-4301-91d3-0e9f5d856ecd" style="width:75%" class="column"><figure id="46a008dd-63d4-4d82-8150-22c720a0ca31" class="image"><a href="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%207.png"><img style="width:240px" src="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%207.png"/></a></figure></div></div><p id="926ccaa2-479d-48f6-a2f6-8d7e37166585" class="">
</p><hr id="2512e1f0-3e2d-4523-8040-d68bbc325231"/><h3 id="e62c2eb4-391c-45af-9265-fd83340b96da" class="block-color-teal_background"><strong>Tree Algorithms: </strong></h3><h3 id="9b69aeb2-d622-4d7e-bd42-5ed80ee06a1e" class="block-color-red_background"><strong>Tree traversal:</strong></h3><div id="65e6229a-08ce-4edb-b601-da2452fa8dcb" class="column-list"><div id="34a5d0dd-e639-4923-ac9e-a2a0f64856d3" style="width:25%" class="column"><ul id="48c3d960-92aa-4719-ad3a-43c1dadb776f" class="bulleted-list"><li><strong>Preorder NLR </strong>— root → left subtree → right subtree<pre id="4e15564f-ee81-4b15-82f4-d3d5a5813579" class="code"><code>void printPreorder(BSTree t) {
        if (t == NULL) return;
        printf(&quot;%d &quot;, t -&gt; value);
        printPreorder(t -&gt; left);
        printPreorder(t -&gt; right);
}</code></pre><p id="04d4069d-43e3-4abb-8eb7-a45f6499ac84" class=""><em>Iterative alternative, using a stack</em></p><pre id="643d0735-59ed-4e9d-88a8-2d6eae7d0d99" class="code"><code>void printPreorder(BSTree t) {
        Stack stack= StackNew();   // Stack contains BSTree nodes
        StackPush(stack, t);
        while (StackSize(s) &gt; 0) {
                BSTree curr = StackPop(stack);
                printf(&quot;%d &quot;, curr -&gt; value);
                if (curr -&gt; right != NULL) StackPush(curr -&gt; right);
                if (curr -&gt; left != NULL) StackPush(curr -&gt; left);
        }
        StackFree(stack);
}</code></pre></li></ul></div><div id="7ffa7e9e-b618-4eb6-8052-dbe1c5a713e3" style="width:25%" class="column"><ul id="232c0b2d-020d-4577-84c8-9b2676e96464" class="bulleted-list"><li><strong>Inorder LNR</strong><em> </em>— left subtree → then root → then right subtree<pre id="8bd7e5b2-643d-4973-9899-13b62a60e1c1" class="code"><code>void printInorder(BSTree t) {
        if (t == NULL) return;
        printInorder(t -&gt; left);
        printf(&quot;%d &quot;, t -&gt; value);
        printInorder(t -&gt; right);
}</code></pre></li></ul></div><div id="a46fdae6-0417-482b-bd92-59caad50d6a5" style="width:25%" class="column"><ul id="d076385b-947a-4035-b630-7fdf5743d353" class="bulleted-list"><li><strong>Postorder LRN</strong><em> </em>— left subtree → right subtree → then root<pre id="fda25078-7d40-4432-8f5d-110569818ac4" class="code"><code>void printPostorder(BSTree t) {
        if (t == NULL) return;
        printPostorder(t -&gt; left);
        printPostorder(t -&gt; right);
        printf(&quot;%d &quot;, t -&gt; value);
}</code></pre></li></ul></div><div id="990d60cf-d0b1-450e-bb6b-eb8b195b2e91" style="width:25%" class="column"><ul id="84164ed2-935c-4b03-acb0-3775d836ffb0" class="bulleted-list"><li><strong>Level-order</strong><em> </em>— root → all its children from left to right → then their children from left to rightand so on<pre id="86a87d78-af94-438d-8705-5814aa1ea079" class="code"><code>void printLevelOrder(BSTree t) {
        Queue q = QueueNew();   // Stack contains BSTree nodes
        QueueEnqueue(q, t);
        while (QueueSize(s) &gt; 0) {
                BSTree curr = QueueDequeue(q);
                printf(&quot;%d &quot;, curr -&gt; value);
                if (curr -&gt; left != NULL) QueueEnqueue(curr -&gt; left);
                if (curr -&gt; right != NULL) QueueEnqueue(curr -&gt; right);
        }
        QueueFree(q);
}</code></pre></li></ul><p id="c505fac2-5d38-4248-b6a7-8394ce87e5a9" class="">
</p></div></div><h3 id="7dda2482-18fb-4fc0-b501-318b808053b6" class="block-color-red_background">T<strong>ree Properties:</strong></h3><div id="8cabc3be-4ea4-4861-853c-9f6b954a7a75" class="column-list"><div id="0a3629a0-9c97-4ac1-a425-7e694fd30cad" style="width:33.33333333333333%" class="column"><ul id="2ee1fe99-b9f7-412a-a0eb-bd113f16b706" class="bulleted-list"><li><strong>Searching for node:</strong><pre id="8e150a18-d1e2-4add-9fba-61d903a1fb4b" class="code"><code>bool BSTSearch(BSTree t, int target) {
        if (t == NULL) return false;
        if (t -&gt; value == target) {      // Target has been reached
                return true;
        }
        else if (target &lt; t -&gt; value) {  // Go search for the target in the left subtree
                return BSTSearch(t -&gt; left, target);
        }
        else if (target &gt; t -&gt; value) {  // Go search for the target in the right subtree
                return BSTSearch(t -&gt; right, target);
        }
}</code></pre></li></ul></div><div id="32eab10e-6f79-4f28-a14f-0267c5c5aaa1" style="width:33.33333333333334%" class="column"><ul id="c01f42df-3722-4638-8cee-7b31c2b5b716" class="bulleted-list"><li><strong>Counting nodes:</strong><pre id="19f2ebfd-b90a-4ba8-a966-6b233ae837ae" class="code"><code>int count(Tree t) {
        return t == NULL ? 0 : 1 + count(t -&gt; left) + count(t -&gt; right);
}</code></pre><p id="d0eddf25-8ce1-45d1-9068-cb2d5a26ede5" class="">
</p></li></ul></div><div id="90bf2ddb-4dbe-47b9-981b-e99560b89e12" style="width:33.333333333333336%" class="column"><ul id="27e9fc75-3656-4b86-85e4-38a0ead13ea2" class="bulleted-list"><li><strong>Getting the height:</strong><pre id="433dc098-9234-4a9f-af19-7a9e19f19aa1" class="code"><code>int TreeHeight(Tree t) {
    if (t == NULL) return 0;
    if (t -&gt; left == NULL &amp;&amp; t -&gt; right == NULL) return 0;       // Do I need this?
    if (t -&gt; left == NULL &amp;&amp; t -&gt; right != NULL) return 1 + TreeHeight(t -&gt; right);
    if (t -&gt; right == NULL &amp;&amp; t -&gt; left != NULL) return 1 + TreeHeight(t -&gt; left);
    return 1 + max(TreeHeight(t -&gt; left), TreeHeight(t -&gt; right));
}</code></pre></li></ul></div></div><h3 id="877c2bdc-0b14-415b-90d4-dc816ec98034" class="block-color-red_background"><strong>Tree Maintenance:</strong></h3><div id="57288c08-3719-4c49-b309-11cce5fe920f" class="column-list"><div id="25e73ee7-f00b-4d8b-a756-72a006db77e6" style="width:43.75%" class="column"><ul id="a1479be5-d1a2-4e43-82de-db9db1487776" class="bulleted-list"><li><strong>Merging two trees:</strong>
<em>Pre-condition: </em>takes 2 trees, <code>t1</code> and <code>t2</code>
<em>Post-condition:</em> ordered binary search-tree with all items in <code>t1</code> and <code>t2</code>
1. Find min node in <code>t2</code>: keep going left until NULL. We are guaranteed that this min node will have no left subtree
2. Set this min node to be the main root node of the resultant tree
3. Set the right subtree of the min node (if it exists) as the left subtree of the root node of <code>t2</code>
4. Set <code>t1</code> as the left subtree of the min node
Return min node (which is the new root)<figure id="60569c3e-c7dc-4130-b0bb-d3d638f88455" class="image"><a href="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%208.png"><img style="width:480px" src="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%208.png"/></a></figure></li></ul></div><div id="9cec8430-860b-4d3c-afd7-35a4eec608bb" style="width:56.25%" class="column"><pre id="b67cd959-ad9c-44d5-bf93-56a482fca67b" class="code"><code>Tree JoinTree(Tree t1, Tree t2) {
        if (t1 == NULL) return t2;
        if (t2 == NULL) return t1;
        Tree minNode = t2; 		
        Tree minNodeParent = NULL;
        while (minNode -&gt; left != NULL) {  // Find the minimum node of t2
                minNodeParent = minNode;
                minNode = minNode -&gt; left;
        }
        if (minNodeParent != NULL) {
                minNodeParent -&gt; left = minNode -&gt; right;
                minNode -&gt; right = t2;
        }
        minNode -&gt; left = t1;
}</code></pre></div></div><div id="afa00382-5dc3-44cd-9774-fe0091edb87a" class="column-list"><div id="9181e56d-0b4f-47b2-b71c-f5723e34507d" style="width:50%" class="column"><ul id="654755cf-ef3e-4fc0-9fbf-9eba35e2505c" class="bulleted-list"><li><strong>Right rotation:
</strong>Moves the left child to root, assigning the original root as the left child&#x27;s right subtree<pre id="e03cc684-e4a0-4af8-ba7f-22bff1a0d6af" class="code"><code>BSTree rotateR(BSTree t) {         // Shifts root node right-down and the pivot node right-up
        if (t == NULL) return NULL;       
        BSTree pivot = t -&gt; left;
        if (pivot == NULL) return t;   // If t has no left component, then we can&#x27;t do a meaningful right rotation
        t -&gt; left = pivot -&gt; right;    // Assign the pivots right subtree to be the left subtree of the previous root
        pivot -&gt; right = t;            // Assign the previous root to be the right child of the pivot
        return pivot;                  // Pivot is the new root
}</code></pre></li></ul></div><div id="b54965aa-a412-45dd-b5c4-48a5cddccf97" style="width:50%" class="column"><ul id="e4fc2e2f-2946-458f-be55-fbc15bb257c2" class="bulleted-list"><li><strong>Left rotation:
</strong>Moves the right child to root, assigning the original root as the right child&#x27;s left subtree<pre id="ecdbb645-53be-489e-9bd2-d4d53c42c975" class="code"><code>BSTree rotateR(BSTree t) {         // Shifts root node left-down and the pivot node left-up
        if (t == NULL) return NULL;       
        BSTree pivot = t -&gt; right;
        if (pivot == NULL) return t;   // If t has no right element, then the left rotation does nothing
        t -&gt; right = pivot -&gt; left;    // Assign the pivots left subtree to be the right subtree of the previous root
        pivot -&gt; left = t;             // Assign the previous root to be the left child of the pivot
        return pivot;                  // Pivot is the new root
}</code></pre></li></ul></div></div><div id="3ff71f1a-597a-49de-b332-cdf1eed6c87c" class="column-list"><div id="65e8e4ea-81c5-4b27-b160-ae0e3a98e879" style="width:37.5%" class="column"><ul id="06afc760-85c7-4eb2-ba1c-6b1a134ad396" class="bulleted-list"><li><strong>Inserting at leaf:</strong>
Insertion algorithm terminates when current node is NULL, which means we have reached a suitable leaf position<pre id="7477588e-d8fa-48f4-af1a-76e08b570589" class="code"><code>BSTree BSTreeInsert(BSTree t, int val) {
        if (t == NULL) {                        // Reached leaf node (terminating case)
                BSTree newLeaf = malloc(sizeof(struct BSTNode));
                newLeaf -&gt; value = val;
                newLeaf -&gt; left = NULL;
                newLeaf -&gt; right = NULL;
                return newLeaf;
        } 
        if (t -&gt; value == val) return t;        // Tree already contains the value. Just return

        if (val &lt; t -&gt; value) {                 // Go insert in the left subtree
                t -&gt; left = BSTreeInsert(t -&gt; left, val);
        } else if (val &gt; t -&gt; value) {        	// Go insert in the right subtree
                t -&gt; right = BSTreeInsert(t -&gt; right, val);
        } 
        return t;
}</code></pre><p id="8f7daac5-4822-4fb8-9197-47d3b615b50f" class="">
</p></li></ul></div><div id="68dc1802-4d3a-42b2-8f18-750e291bb449" style="width:37.5%" class="column"><ul id="2a01ea61-4967-4913-8858-263ac67bc3f2" class="bulleted-list"><li><strong>Inserting at root:</strong>
Like insertion at the leaf but requires rearrangement of the tree for each insert. Recent entries are close to the root so retrieving these are quicker than if we were to insert at the leaf everytime. 
1. Insert new node as leaf
2. Lift the new node to the root by a series of rotations<pre id="6d275f64-bbcf-4cb1-a29a-6e4c18478c03" class="code"><code>BSTree BSTreeInsert(BSTree t, int val) {
        if (t == NULL) {
                BSTree newLeaf = malloc(sizeof(struct BSTNode));
                newLeaf -&gt; value = val;
                newLeaf -&gt; left = NULL;
                newLeaf -&gt; right = NULL;
                return newLeaf;
        }
        if (val &lt; t -&gt; value) {
                t -&gt; left = BSTreeInsert(t -&gt; left, val); 
                return rotateRight(t);
        }
        else if (val &gt; t -&gt; value) {
                t -&gt; right = BSTreeInsert(t -&gt; right, val);
                return rotateLeft(t);
        }
    // If the execution reaches here, the value probably already exists in the tree. Do nothing
        return t;
}</code></pre><p id="fd6b03d6-abbf-4e7f-adfd-d768857dac71" class="">Time-complexity: <em>O(height)</em></p></li></ul></div><div id="9f41e6e0-2320-40cc-a6ab-1883b30d8c28" style="width:25.00000000000001%" class="column"><figure id="52a327a3-413f-401d-a9d6-b60913325464" class="image"><a href="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%209.png"><img style="width:384px" src="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%209.png"/></a></figure><p id="59b344c0-8e27-4681-9786-13b1f59fc58b" class="">
</p></div></div><div id="24aadec9-a020-44cb-9f40-584cfe50576d" class="column-list"><div id="e0a1b306-c745-422b-81d9-3b4d2a69b8df" style="width:50%" class="column"><ul id="3d38c544-511f-42ad-ad94-d168f23864d2" class="bulleted-list"><li><strong>Deleting a node:
</strong>Do a regular search for the target node and then handle deletion by cases once reached: 
1. Target has no subtrees — simple deletion
2. Target has 1 subtree — replace target with its child
3. Target has 2 subtrees — call mergeTrees to merge the target&#x27;s children to replace the deleted target
4. Target doesn&#x27;t exist — do nothing and return<pre id="8f487c43-0218-4dd5-9246-030dd475e630" class="code"><code>Tree deleteNode(Tree t, int target) {
        if (t != NULL) {
                if (t -&gt; value &gt; target) {        // Target is somewhere in the left subtree
                        deleteNode(t -&gt; left, target);
                }
                else if (t -&gt; value &lt; target) {   // Target is somewhere in the right subtree
                        deleteNode(t -&gt; right, target);
                }
                else if (t -&gt; value == target) {  // Reached the target node
                        if (t -&gt; left != NULL &amp;&amp; t -&gt; right != NULL) {  // Both subtrees exist
                                Tree t1 = t -&gt; left;
                                Tree t2 = t -&gt; right;
                                free(t);
                                return mergeTree(t -&gt; left, t -&gt; right);
                        }
                        else if (t -&gt; left != NULL) {   // Only the left subtree exists
                                Tree ret = t -&gt; left;
                                free(t);
                                return ret;
                        }
                        else if (t -&gt; right != NULL) {  // Only the right subtree exists
                                Tree ret = t -&gt; right;
                                free(t);
                                return ret;
                        } 
                        else {  // No subtrees. Simple deletion
                                free(t);		
                                return NULL;						
                        }
                }
        }
        return t;
}</code></pre></li></ul></div><div id="5273a48b-bc29-4070-bb87-148e591f3e47" style="width:50%" class="column"><ul id="4dc45149-a5ef-4cee-b5c5-1022288e0f06" class="bulleted-list"><li><strong>Rebalancing:</strong><strong> </strong>
Logic to rebalance any BST: 
1. Set the <em>median node as the new root </em>using the <code>partition()</code> function
2. Recurse through each subtree, setting the <em>median node as the new root </em>for every single node<p id="73f6a822-27b9-4958-affa-517e39050c3a" class="">Time-complexity of rebalancing is <em>O(N)</em> because each node is visited
We can choose to rebalance periodically (eg. after every 20 insertions), or whenever the tree&#x27;s imbalance exceeds a threshold</p><pre id="76991b22-6cdd-4ba3-91b3-edc78b030326" class="code"><code>Tree Rebalance(Tree t) {
        if (countNodes(t) &gt;= 3) {
                Tree newRoot = Partition(t, n / 2);  // Sets the node at index n/2 (the median node) as the new root
                t -&gt; left = Rebalance(t -&gt; left);    // Rebalance both subtrees
                t -&gt; right = Rebalance(t -&gt; right);
        }
        return t;
}</code></pre></li></ul><ul id="327bd10f-347f-4dec-a26f-a0c4a73ec2cb" class="bulleted-list"><li><strong>Partition:</strong>
Sets the node at a <em>chosen index</em> to be the new root (using a sequence of tree rotations to lift the node at the chosen index up to the root). 
1. Count the nodes in the left subtree, if it is equal to the target index, then the current node is the one we were after — just return t
2. If the index is greater than the number of nodes in the left subtree, then we know that the target node is somewhere in the <pre id="22ade3f0-a39a-4b93-903e-72005d5965e6" class="code"><code>Tree Partition(Tree t, int newRootIndex) {
        int leftNumNodes = countNodes(t -&gt; left);
        if (leftNumNodes &gt; newRootIndex) {       // The rootIndex is somewhere in the left subtree
                t -&gt; left = Partition(t -&gt; left, newRootIndex);		
                t = rotateRight(t);    // Rotate right, to lift the new median node up to root
        }
        else if (leftNumNodes &lt; newRootIndex) {  // The rootIndex is somewhere in the right subtree 
                t -&gt; right = Partition(t -&gt; right, newRootIndex - leftNumNodes - 1);
                t = rotateLeft(t);     // Rotate left, to lift the new median node up to root
        }
        return t;
}</code></pre></li></ul><p id="c808868f-7261-4746-ac05-7f0163b04ee1" class="">
</p></div></div><hr id="aa5e7e1f-f3f2-4df6-973c-972f02a31420"/><h1 id="cd10eb54-a018-445d-8ecd-cbd3e17c3a35" class="block-color-blue_background">Week 4: Trees II — Specialised Search Trees</h1><ul id="1d1189d1-bc54-4176-9726-ad036c3958f0" class="bulleted-list"><li>The BST shape depends on the order of insertion. 
The best case is that the values are inserted in preorder, so median value first, then the median of the left half, then the median of the right half, and so on
The worst case is that the values are inserted in order or reverse order, forming a degenerate tree</li></ul><ul id="bf423857-0065-42e2-b652-e45681065c1a" class="bulleted-list"><li>Randomised trees makes worst case performance unlikely</li></ul><ul id="6f1df4e7-de75-4dbb-b126-8fd4c110fde1" class="bulleted-list"><li>Splay-trees, randomised trees and occasional rebalance trees have worst case of O(N), but ideally, we want <em>O(log(n)).
</em>AVL trees fix imbalances as they arise, therefore maintaining a height of log(n). Repairs are done locally and not on the overall tree
2-3-4 trees use varying-sized nodes to assist balance</li></ul><p id="aaa19d52-1097-4af9-9f02-d257296fae98" class="">
</p><h3 id="7a8c0e7c-af14-4a6c-b78f-134cb096c805" class="block-color-teal_background"><strong>Splay Trees:</strong></h3><ul id="005127ee-3f99-42c2-9fc5-c239342261bd" class="bulleted-list"><li>Like BST but new entries are always inserted at the root and searched entries are always brought up to the root (this is called &quot;splaying&quot;). This behaviour models caching, which means recently interacted with nodes are quicker to retrieve<ul id="4fc9f021-1021-4929-ba30-aa1a7b2ae686" class="bulleted-list"><li>The insert for splay trees modifies the standard <code>insertAtRoot()</code> function. Considers parent-child-grandchildren links and performs a sequence of rotations depending on the orientation of parent to child to grandchildren. This tends to improve tree balance more than the standard <code>insertAtRoot()</code> function</li></ul></li></ul><ul id="6347fc00-a393-48e5-9ec0-2ec6346df9a7" class="bulleted-list"><li>Amortised cost — allows very quick retrieval of recent nodes but at the cost of a slower insertion and search strategy, but splaying also tends to improve the balance of the tree
Search operations are still O(n) since the tree is explicitly maintaining balance. </li></ul><p id="b972c6e1-7b34-4467-914d-823f1668f082" class="">
</p><p id="94f6da1b-79cd-4131-a450-05305b1cfb45" class="">Target node belongs somewhere in the grandchildren subtrees — zig-zig and zig-zag cases: </p><ol id="971b8b4b-c9c8-4fe5-82c6-6d932750b35c" class="numbered-list" start="1"><li>Target node is in the left child&#x27;s left child — zig-zig:      <code>rotateRight(t)</code> twice</li></ol><ol id="8dca0229-2845-400d-b9f1-6b82371a3996" class="numbered-list" start="2"><li>Target node is in the left child&#x27;s right child — zig-zag:   <code>rotateLeft(t → left)</code> then <code>rotateRight(t)</code></li></ol><ol id="ef5953be-e582-4cd5-8ba2-e392065bd8dc" class="numbered-list" start="3"><li>Target node is in the right child&#x27;s left child — zig-zag:   <code>rotateRight(t → right)</code> then <code>rotateLeft(t)</code></li></ol><ol id="809bb688-20fe-4904-8589-835138afc230" class="numbered-list" start="4"><li>Target node is in the right child&#x27;s right child — zig-zig: <code>rotateLeft(t)</code> twice</li></ol><p id="4224ffe7-dae2-4a1a-af3c-d9f58181fca0" class="">If the target node belongs in the left </p><pre id="c077b8df-353f-41f6-8fb5-e1789d2360c3" class="code"><code>// Lifts a target node to the root by a sequence of rotations depending on cases
struct node *splay(struct node *root, int target) { 
    if (root == NULL || root-&gt;key == key) return root;   // Terminating case: either root is NULL root contains key
    
        // Target is somewhere in left subtree  
        if (root -&gt; value &gt; target) {  
        if (root -&gt; left == NULL) return root;                     // Target must be in the left child, but there is no left child, so the key must not exist

                // Dealing with zig-zig and zig-zag:
        if (root -&gt; left -&gt; value &gt; target) {                      // Target must belong somewhere in the left child&#x27;s left child - Zig-Zig
            root -&gt; left -&gt; left = splay(root -&gt; left -&gt; left, key);   // This call to splay recursively lifts the target node to become the root of the left-left node
            root = rightRotate(root);                              // Do FIRST rotation on the parent node
        } 
        else if (root -&gt; left -&gt; value &lt; target) {                 // Target must be somewhere in the left child&#x27;s right child
            root -&gt; left -&gt; right = splay(root -&gt; left -&gt; right, target);  // This call to splay recursively lifts the target node to become the root of the left-left node
            if (root -&gt; left -&gt; right != NULL)                     // If the the left child&#x27;s right child exists, then call rotateLeft on the left child
                root -&gt; left = leftRotate(root -&gt; left); 
        } 
        return (root -&gt; left == NULL) ? root: rightRotate(root);   // Do SECOND rotation, only if the right subtree exists
    } 

        // Target is somewhere in the right subtree
    else {  
        if (root -&gt; right == NULL) return root;                    // Right subtree doesn&#x27;t exist so the target doesn&#x27;t either
                // Dealing with zig-zig and zig-zag:
        if (root -&gt; right -&gt; value &gt; target) { 
            root -&gt; right -&gt; left = splay(root -&gt; right -&gt; left, target);     // Lifts the target to the root of the right child&#x27;s left subtree 
            if (root -&gt; right -&gt; left != NULL) 
                root -&gt; right = rightRotate(root -&gt; right); 
        } 
        else if (root -&gt; right -&gt; value &lt; target) { 
            root -&gt; right -&gt; right = splay(root -&gt; right -&gt; right, target);   // Bring the key as root of right-right and do first rotation 
            root = leftRotate(root); 
        } 
        return (root-&gt;right == NULL)? root: leftRotate(root);      // Do second rotation for root
    } 
}</code></pre><p id="afffad06-68b4-4887-8ab0-2e91a2498512" class="">Time-complexity: O(n) — but a better average case usually</p><p id="9978f0a4-5d6b-4a2f-b1c9-4a438c97c05b" class="">
</p><h3 id="205633f9-5077-4d78-bc7a-812075523194" class="block-color-teal_background">AVL-Trees:</h3><ul id="c962e03b-1a53-4f4d-8799-bec96079cb10" class="bulleted-list"><li>AVL trees fix imbalances as soon as they occur by checking the height of left and right subtrees in its insertion function <code>AVLInsert()</code>. An imbalance is when <code>abs(leftSubtreeHeight - rightSubtreeHeight) &gt; 1</code></li></ul><ul id="a70c1150-dd93-43f0-a420-237d07d3ce29" class="bulleted-list"><li>The maximum height difference between <em>any node&#x27;s subtrees</em> is 2, since the precondition is that we are given an AVL height balanced tree</li></ul><ul id="fd312366-ea09-4863-85c4-40a74d53aece" class="bulleted-list"><li>Getting the height of a tree may be expensive, so AVL trees tend to have poorer performance for insertion operations as a tradeoff for a <em>O(logn) </em>search function. 
It may help to augment the struct declaration with more fields that keeps track of height differences, for example.</li></ul><div id="5ea1b455-103c-4f8c-bebf-74708483717a" class="column-list"><div id="3f74a77c-59fb-4e03-8d6f-8253736fe1d0" style="width:75%" class="column"><pre id="d2e7a7bd-4110-406b-84ee-f6e69aab6ae7" class="code"><code>Tree AVLInsert(Tree t, int val) {        // Expects the input tree to not have any existing imbalances
        if (t == NULL) return newTree(val);  // This is where insertion occurs
        if (t -&gt; value == val) return t;     // Attempting insert a value that already exists in the tree
        
        if (t -&gt; value &gt; val) {
                t -&gt; left = AVLInsert(t -&gt; left, val);				
        }
        else if (t -&gt; value &lt; val) {
                t -&gt; right = AVLInsert(t -&gt; right, val);
        }
        // After insertion, get the heights and check if a new imbalance needs to be fixed
        int leftHeight = getHeight(t -&gt; left);
        int rightHeight = getHeight(t -&gt; right);
        if (leftHeight - rightHeight &gt; 1) {  // This means the left subtree is exactly 2 nodes deep (imbalances can only ever be a 2 node difference because we have a balanced tree to begin with)
                if (val &gt; (t -&gt; left -&gt; data)) {
                        t -&gt; left = rotateLeft(t -&gt; left);
                        t = rotateRight(t);
                } else {
                        t = rotateRight(t);
                }
        }
        else if (rightHeight - leftheight &gt; 1) {  // Right subtree has 2 nodes more than the left
                if (val &lt; (t -&gt; right -&gt; data)) {
                        t -&gt; right = rotateRight(t -&gt; right);
                        t = rotateLeft(t);
                } else {
                        t = rotateLeft(t);
                }
        }
        return t;		
}</code></pre></div><div id="be9a3977-867b-49f5-84b5-5d3be966d021" style="width:24.999999999999993%" class="column"><figure id="e6672b04-a44e-41a9-9e97-55bdd5028e72" class="image"><a href="https://upload.wikimedia.org/wikipedia/commons/f/fd/AVL_Tree_Example.gif"><img style="width:480px" src="https://upload.wikimedia.org/wikipedia/commons/f/fd/AVL_Tree_Example.gif"/></a></figure></div></div><h3 id="7a7041b0-a1b3-47c9-8517-0c14a9a8b7c0" class="block-color-teal_background">2-3-4 Trees: </h3><div id="93e72d5b-55bf-4da9-8ee8-22c6a7aad481" class="column-list"><div id="2639188a-159b-4cea-8566-011aeeeed4b2" style="width:50%" class="column"><p id="c597eb75-e1cb-456c-9124-e812532e4442" class="">2-3-4 trees have special nodes:</p><ul id="3dd6c3a5-da25-44c9-ad52-83a633129637" class="bulleted-list"><li>1-value node: can have 2 subtrees</li></ul><ul id="c058d385-aed8-44aa-9ccb-1fcb6aae9058" class="bulleted-list"><li>2-value node: can have 3 subtrees</li></ul><ul id="a59f9b4b-8406-485a-bb87-740911df209f" class="bulleted-list"><li>3-value node: can have 4 subtrees</li></ul><p id="65489787-e5b1-4076-9927-48afcbe0be10" class="">In 2-3-4 trees, <em>all leaves are equidistant from the root,</em> meaning all leaves are on the same bottom level. The insertion function for 2-3-4 trees will always maintain height balance</p><figure id="de7b37b0-2424-4401-8013-2f5fd96b1bcb" class="image"><a href="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%2010.png"><img style="width:528px" src="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%2010.png"/></a></figure><p id="b2a00406-b486-436f-810f-1df89e463b6c" class=""><em>2-3-4 Search:</em></p><pre id="0d85cc33-2741-4389-9d98-4d2709c3571f" class="code"><code>Tree Search234(Tree t, int item) {
        if (t == NULL) return t;
        int slotIndex = 0;
        while (slotIndex &lt; (t -&gt; type- 1) &amp;&amp; item &gt; t -&gt; nodeValues[slotIndex) {
                // Keep iterating until either we&#x27;ve reached the end of the current node&#x27;s values or if we&#x27;ve bumped into a value greater than the one we want
                slotIndex++;  
        }
        if (item == t -&gt; nodeValues[slotIndex]) {
                return t;  // Item was found in the current node
        } else {
                return Search234(t -&gt; children[slotIndex], item)  // Item was not found in the current node and so must be somewhere in the child at slotIndex
        }
}</code></pre><p id="ea47c414-1ebf-4dd8-9152-0b08d83d2404" class=""><em>Time-complexity</em>:</p><ul id="621614e4-9ec2-4f1a-a60a-f3a261228a7a" class="bulleted-list"><li>Worst case: all nodes are 2-nodes, so O(log2(n)). Remember, 2-3-4 trees are always height balanced</li></ul><ul id="fc7e0354-1131-4fb3-82dc-34d378669cfb" class="bulleted-list"><li>Best case: all nodes are 4-nodes, so O(log4(n))</li></ul><p id="1703a451-eac0-4eb2-b283-0b3975c341e8" class="">
</p></div><div id="0f1aeb22-8a75-45ec-a4fd-fef2896ab128" style="width:50%" class="column"><p id="45c8f416-42dc-463c-b39b-1429e3ac0b84" class=""><em>Possible struct declaration</em></p><pre id="c5c908cc-a1a8-4fd7-a3e3-5b7302a3c83e" class="code"><code>struct treeNode {
        int type;                      // Can take the values: 2, 3 or 4
        int nodeValues[3];             // Items held in the node (a 4 node holds a maximum of 3 values)
        struct treeNode *children[4];  // Array of pointers to children treeNodes
};</code></pre><p id="0a541eb6-03b4-4397-b934-a5544db53300" class=""><em><strong>234Insert</strong></em></p><ol id="ee3b79ba-1b2a-45db-a544-4afd41ee921d" class="numbered-list" start="1"><li>Find where to insert using Search()</li></ol><ol id="6c746843-6100-40c6-a00d-b8701908329f" class="numbered-list" start="2"><li>If not full, insert into the node&#x27;s <code>nodeValues[ ]</code> and promote its type, <code>type++</code></li></ol><ol id="30f4b6b1-186d-416e-8d48-cb84dd308539" class="numbered-list" start="3"><li>If full: <ul id="20b52b05-8887-4be1-b5b8-3b8b35bd3181" class="bulleted-list"><li>Push the middle node <code>nodeValues[1]</code> into the parent&#x27;s <code>nodeValues</code> array, then split into two 2-nodes, storing nodeValues[0] and nodeValues[1] and inserting the new entry into the correct 2-node<ul id="9b4f697f-7ef6-4bb9-9271-5155aa5b88be" class="bulleted-list"><li>If the parent is also full, then the parent must be split as well by the same process</li></ul><ul id="98d8e4a3-736d-4c48-9be2-20d0a304acb4" class="bulleted-list"><li>If the root node is full, then it must be split by the same process but create a new 2-node as the new root</li></ul></li></ul></li></ol><p id="539010d4-5983-46c4-bab6-e66a7cf98ca0" class=""><em>2-3-4 Insertion 
Just watch the visualisation (implementation out of the scope of this course): </em><em><a href="https://people.ok.ubc.ca/ylucet/DS/BTree.html">https://people.ok.ubc.ca/ylucet/DS/BTree.html</a></em><em>):</em></p><pre id="efb143c1-65cc-4b38-b972-c9fc109380ab" class="code"><code>Tree Insert234(Tree t, int item) {
        if (t == NULL) return newTree(item);
        Tree insertionNode = Search234(t, item);
        Tree parentNode = parent of insertionNode;  // Parent of insertionNode

        if (insertionNode -&gt; type &lt; 4) {  // Node is not full
                insertionNode -&gt; type++;      // Insert into ordered array
        }
        else {  // Node is full
                int promoteVal = insertionNode -&gt; nodeValues[1];
                Tree newLeaf1 = newTree(insertionNode -&gt; nodeValues[0]);
                Tree newLeaf2 = newTree(insertionNode -&gt; nodeValues[2]);
                if (item &lt; newLeaf1) {        // Insert in the left leaf fragment
                        Insert234(newLeaf1, item);
                }
                else {  // Otherwise insert in the right leaf fragment
                        Insert234(newLeaf2, item); 
                }
                if (parentNode == t) {        // If the parent is the root, then split the root by the same process and 
                        
                }
                Insert234(parentNode, promoteVal);
                while(parentNode -&gt; order == 4) {
                        continue promoting nodes up
                }
                if (parentNode == root of tree &amp;&amp; parent -&gt; order == 4) {
                        split root, malloc a new node and set that as the new root of the entire tree
                }
        }
}</code></pre></div></div><h1 id="0c4177d4-364a-45bc-98e4-4369a347eb9a" class="block-color-blue_background">Week 5: Graphs I</h1><h3 id="fbe61718-6a8e-4c74-9812-20ca62a54eee" class="">Graph Data Structures</h3><p id="a65fd459-1647-4e90-ab33-f6a3ee2c0829" class="">A graph is a set of Vertices <em>V</em> and a set of edges <em>E</em> (a subset of the Cartesian product <em>V × V</em>)</p><div id="5107a8f8-a0db-4c85-a70c-e11d28809b5d" class="column-list"><div id="ddc67f54-50de-473c-b4db-c774a44a8ebc" style="width:29.166666666666664%" class="column"><p id="33243c8d-0e70-403e-a2ac-14a5b9242202" class=""><strong>Graph Theory basics:</strong></p><ul id="75253b91-a872-4899-b787-13d3148467dc" class="bulleted-list"><li>A graph with <em>V</em> vertices has at most <em>V(V-1)/2</em> edges</li></ul><ul id="f7b61ccb-5573-479d-96d6-a21be7231803" class="bulleted-list"><li>A graph is <em>dense </em>if |E| is closer to V²
A graph is <em>sparse </em>if |E| is closer to V </li></ul><ul id="0e9ca5eb-bde5-4ab4-a5b6-5c9b56146d62" class="bulleted-list"><li>Connected vertices are called <em>adjacent</em>. The edge between them is <em>incident </em>on them</li></ul><ul id="88b24082-2165-43dc-ad9e-e1212f24bd6d" class="bulleted-list"><li><strong>Degree:</strong> number of edges <em>incident </em>on a vertex</li></ul><ul id="9478b872-5ce6-4feb-bc72-5419741fcaaf" class="bulleted-list"><li><strong>Walk:</strong> a sequence of vertices to travel from one vertex to another</li></ul><ul id="35c7cd13-5380-4cb5-9823-f1757e0ef4e7" class="bulleted-list"><li><strong>Path:</strong> a <em>walk</em> with no repeated vertices (hence no repeated edges)<ul id="da9c49cd-f836-46e6-9dd9-98c1bc090e0a" class="bulleted-list"><li><strong>Euler path:</strong> a <em>path </em>that includes <em>all edges exactly once</em>, possibly revisiting used vertices</li></ul><ul id="010c65d3-8573-4894-92f2-b3a05691f6b8" class="bulleted-list"><li><strong>Hamiltonian path:</strong> a <em>path </em>that includes <em>all vertices exactly once</em>, possibly revisiting used edges</li></ul></li></ul><ul id="4e895357-e35b-4d32-a477-e2ba5c52ea0c" class="bulleted-list"><li><strong>Circuit:</strong> a <em>path </em>that ends on the same vertex<ul id="c8c64016-8128-4f73-9455-a17612102ef2" class="bulleted-list"><li><strong>Euler circuit:</strong> a <em>circuit</em> including <em>all edges exactly once</em>, possibly revisiting used vertices</li></ul><ul id="c5288183-c997-4ea1-8012-fed01d204721" class="bulleted-list"><li><strong>Hamiltonian circuit:</strong> a <em>circuit </em>including <em>all vertices exactly once</em>, possibly revisiting used edges</li></ul></li></ul></div><div id="1d96aff0-ff93-4ced-ba1c-640beabd420d" style="width:41.666666666666664%" class="column"><p id="aa02d868-5892-4064-a9d3-ed318b5274ee" class=""><strong>Graph Types:</strong></p><ul id="f7818606-2174-492d-aeb7-5fd49dfbfcdf" class="bulleted-list"><li><strong>Connected graph: </strong>there exists a <em>path between any two vertices</em></li></ul><ul id="d0dde94c-8a16-4be9-8e04-0a3f908ddebc" class="bulleted-list"><li><strong>Complete graph:</strong><em> </em>there is an edge from every vertex to every other vertex (|E| = V(V-1)/2, which is the maximal amount of edges a graph can have)</li></ul><ul id="f31def58-d87b-4ea9-aedb-171825aafbc6" class="bulleted-list"><li><strong>Tree:</strong><em> connected subgraph </em>of the graph containing no possible <em>circuits</em><ul id="0da6e830-f36f-41b7-9e98-cef2e6896409" class="bulleted-list"><li><strong>Spanning tree:</strong> a <em>tree</em> containing every vertex in the original graph<ul id="d319b6f4-a254-4ece-802b-82d0d694af90" class="bulleted-list"><li><strong>Minimum spanning tree: </strong>a <em>spanning tree </em>where the sum of all weights is minimised. </li></ul><ul id="e9a6e7d9-5198-4b65-b534-531bd3277652" class="bulleted-list"><li><strong>Shortest path spanning tree:</strong> a spanning tree where the weighted paths from a source vertex to every other vertex is minimised </li></ul></li></ul></li></ul><ul id="2247fd7d-aeef-43c3-88d2-caa2209d771f" class="bulleted-list"><li><strong>Clique: </strong>a <em>complete graph </em>which is a <em>subgraph </em>of the original graph</li></ul><ul id="0e847b9f-2455-479b-8abd-fbe187426bb1" class="bulleted-list"><li><strong>Undirected graph: </strong>any graph with only bidirectional relations</li></ul><ul id="799cc22e-3512-40f5-b58d-2ca80d997da2" class="bulleted-list"><li><strong>Directed graph:</strong> any graph with unidirectional relations</li></ul><ul id="8955c410-06b7-4bd2-9a23-edc8ce56e08c" class="bulleted-list"><li><strong>Weighted graph:</strong> any graph where edges have an associated value (weight)</li></ul><ul id="20ca19a8-6cc1-400a-a0fc-6768b681789e" class="bulleted-list"><li><strong>Multi-graph: </strong>any graph that contains parallel edges between vertices</li></ul></div><div id="b36eba91-e62d-4c4b-aafd-c8f6acd561cb" style="width:29.166666666666668%" class="column"><p id="57625ee4-de20-45bb-b623-307c170413ea" class=""><em>Possible struct declaration:</em></p><pre id="98253e60-8172-48e0-abe6-61542c80847c" class="code"><code>struct graphRep {
        int numNodes;
        int numEdges;     
        int **edgeMatrix;  // Using an adjacency matrix to store all connections. We could alternatively use an array of edges or an adjacency list
};</code></pre><p id="cc73f4b5-58e3-430e-98f3-6c1ee5815387" class="">
</p></div></div><p id="65fa6168-9920-48b3-9fdb-8f59c590a75f" class=""><strong>Graph Data Structures:
</strong>A graph is representable as an:<em> array of edges</em>, <em>adjacency matrix </em>and <em>adjacency list</em>. These representations each provide sufficient information to reconstruct the same graph diagrammatically. The choice of which underlying data structure to use for a graph ADT depends on which operations we want to optimise the most.</p><div id="e6a17bec-2f43-4dfc-ae1f-451d2023046b" class="column-list"><div id="b21ebdca-b2a3-46de-a687-44fe101ba2bd" style="width:33.33333333333333%" class="column"><p id="fa78e288-886a-4d44-86e4-7a6691a03632" class=""><strong>Array of edges:
</strong><code>{(v1, w1), ..., (vn, wn)}</code> — array of 2-tuples. Could also use 3-tuples to store the weight of the edge.
Vertex tuples are <em>ordered</em> for directed graphs, to encode direction. In undirected graphs, <code>(1, 2)</code> is equivalent to <code>(2, 1)</code></p><p id="acb63194-250a-4cb3-a66e-ce6d29295e61" class=""><em>Time-complexities of functions:</em></p><ul id="ed3fe4ac-9830-4def-992d-d43d760c122f" class="bulleted-list"><li>Initialisating a new graph: O(1) </li></ul><ul id="3fd49379-913c-4961-89da-603ac11e2840" class="bulleted-list"><li>Insertion: O(E) — loop through until the end to check the edge doesn&#x27;t already exist</li></ul><ul id="5862a0cb-0993-49af-8512-3797942287bd" class="bulleted-list"><li>Deletion: O(E) — loop through, delete target, then shift all elements thereafter down by 1 index</li></ul><p id="ffb1f28d-d293-4a3a-831e-b9b38b9cc1e4" class="">Note: if we maintain an ordered array of edges, then the time complexity of insertion and deletion can be reduced to O(log(E)) with a binary search algorithm</p><p id="d2152bed-a687-445a-a639-1cc4cf2c0fee" class=""><em>Space-complexity:</em> O(E)</p><p id="d0ded1bc-37d0-4a04-b45f-d37289453461" class="">
</p></div><div id="727c0559-f376-4be8-83a1-c9350f26c775" style="width:41.666666666666664%" class="column"><p id="f5e6d966-294e-4b54-8311-cbe47f06d104" class=""><strong>Adjacency matrix:
</strong><code><em>V × V</em></code> matrix — where each coordinate in the matrix correspondeds to an edge&#x27;s existence (and its weight, conveniently).
Undirected graphs have a symmetric matrix while directed graphs usually have a non-symmetric matrix</p><p id="6656029e-feef-4904-b1df-52317d88e087" class=""><em>Time-complexities of functions:</em></p><ul id="25b418f9-c652-491f-98f7-d3c65d0f0b1c" class="bulleted-list"><li>Initialisating a new graph: O(V²) — for setting all coordinates to 0</li></ul><ul id="f84495d6-82da-441b-b21b-04f60be34110" class="bulleted-list"><li>Insertion: O(1) — assign a new value to a coordinate</li></ul><ul id="fc912907-b78d-46d9-ac96-3d081083e857" class="bulleted-list"><li>Deletion: O(1) — reset a coordinate to 0</li></ul><p id="28e83b2f-d354-4964-8c12-3e515a27e3aa" class=""><em>Space-complexity:</em> O(V²)</p></div><div id="89e2f7f9-0c04-497f-bf5b-6f7c6d48660c" style="width:25.00000000000001%" class="column"><p id="ed76318a-e1be-4f0e-8ba7-c625b3a505e6" class=""><strong>Adjacency list:
</strong>Array of linked list heads — for each vertex, store a linked list of its neighbour vertices.</p><p id="54949a34-ca15-4b6d-af16-d89d62e01f2b" class=""><em>Time-complexities of functions:</em></p><ul id="c53fc24c-a0d1-4eec-919a-1c1fa136085c" class="bulleted-list"><li>Initialisating a new graph: O(V) — Initialise all linked list heads to <code>NULL</code></li></ul><ul id="2032337f-fdb5-43c8-8816-e97c83eafda2" class="bulleted-list"><li>Insertion: O(1) — access index and insert the vertex value into the linked list</li></ul><ul id="53b67f50-fa40-40b3-9d21-3378997a756f" class="bulleted-list"><li>Deletion: O(E) — search for the target value in the list</li></ul><p id="4d925584-9fb0-4db2-8fc5-c8153eb53696" class=""><em>Space-complexity:</em> O(V+E) — O(V) for the array size, O(E) for the size of the all the linked lists attached to each array index</p></div></div><h3 id="404de8ac-580b-48cb-9512-5071b4b8770f" class="block-color-teal_background">Graph <strong>Algorithms: </strong></h3><h3 id="53de2a61-0153-417b-86ba-4be40dfcf2b7" class="block-color-red_background">Graph Traversal: </h3><p id="dd1e287a-d0ab-4ca0-b353-e967ba048f68" class="">Two traversal methods are depth-first search and breadth-first search. Both use a <code>bool visited[]</code> array to prevent the algorithm from returning to an already visited node</p><div id="cb378420-e83d-48bf-8518-b92bc6749a38" class="column-list"><div id="4793de4f-68b9-465f-995e-a94232960568" style="width:37.50000000000001%" class="column"><p id="712120bb-5f3e-48c1-a00a-d9e1d5cab8ed" class=""><strong>Depth-First Search: 
</strong>Follows one single path to completion and then considers other paths one step back and so on.
Can be implemented recursively or iteratively (using a stack structure)</p><p id="d0064701-ed84-4d92-835a-ee7a8e75b516" class=""><em>A skeleton for a recursive DFS algorithm:</em></p><pre id="fdd9b5cb-b56f-4e6d-be50-0193732b419d" class="code"><code>// Expects all elements of the visited array to be intialised to false
void DepthFirstSearch(Graph g, int start, bool visited[]) {
        visited[start] = true;
        for (int i = 0; i &lt; g -&gt; numVertices; i++) {
                if (isAdjacent(start, i) &amp;&amp; visited[i] == false) {
                        depthFirstSearch(g, i, visited);
                }
        }
}
// Could modify this function to do things like: 
// - print all elements
// - return a bool if a path exists from src to dest, etc.
// - pass a int pred[] array to track predecessor nodes (which lets us then trace and print paths from src to dest)</code></pre><p id="14bddfa3-0314-4635-90cf-6cedfe094a93" class="">Time-complexity: O(V+E) — each vertex is accessed, and possibly every edge</p></div><div id="8bf3750f-31b9-4822-aab6-73ad461d98bf" style="width:33.33333333333333%" class="column"><p id="433a6c04-08dd-47f1-8e9c-4c19332a3de7" class="">



<em>Iterative DFS using a stack ADT:</em></p><pre id="ecb7d6b0-94b3-4858-81f9-220aa1194908" class="code"><code>void DepthFirstSearch(Graph g, int src) {
        bool visited[g -&gt; numVertices];
        for (int i = 0; i &lt; g -&gt; numVertices; i++) visited[i] = false;
        Stack s = newStack();
        StackPush(s, src);
        while (StackSize(s) &gt; 0) {
                int curr = StackPop(s);
                visited[curr] = true;
                for (int i = 0; i &lt; g -&gt; numVertices; i++) {
                        if (isAdjacent(g, curr, i) &amp;&amp; visited[i] == false) {
                                StackPush(s, i);
                        }
                }
        }
        StackFree(s);
}</code></pre><p id="4912d40a-e38f-4644-9afd-212e56863059" class="">
</p></div><div id="304ec72b-85b8-4b9d-8b1a-e88d967557c3" style="width:29.166666666666675%" class="column"><p id="ba913dc9-16a9-404e-abab-c8725a925d0b" class=""><strong>Breadth-First Search:
</strong>Spreads outwards, like a level-order traversal, only considering adjacent vertices. </p><p id="d5ac15ba-df6c-49bf-b17b-7e5c06d7d0aa" class=""><em>A skeleton for iterative BFS: (basically iterative DFS but with a queue ADT)</em></p><pre id="c0f9b1a8-e3a0-422e-90d4-2f59602122c4" class="code"><code>void BreadthFirstSearch(Graph g, int src, bool visited[]) {
        bool visited[g -&gt; numVertices];
        for (int i = 0; i &lt; g -&gt; numVertices; i++) visited[i] = false;
        Queue q = QueueNew();
        QueueEnqueue(q, src);
        while (QueueSize(q) &gt; 0) {
                int curr = QueueDequeue(q);
                visited[curr] = true;
                for (int i = 0; i &lt; g -&gt; numVertices; i++) {
                        if (isAdjacent(g, curr, i) &amp;&amp; visited[i] == false) {
                                QueueEnqueue(q, i);
                        }
                }
        }
        QueueFree(q);
}
// Could use this function for:
// - tracing paths (using an int pred[] array)
// - finding the shortest path (fewest edges) from a source to a destination </code></pre><p id="0349eefc-6330-4bf1-9f98-dc9f6b106676" class="">Time-complexity: O(V+E) — each vertex is visited, and possibly every edge</p></div></div><hr id="810e2480-cb45-4ecd-86f0-7dffcb819f2c"/><h3 id="8808b592-75b2-4acf-9da9-616b47de673e" class="block-color-red_background">Graph Properties: </h3><div id="d17514fd-f423-480b-a3af-689855978636" class="column-list"><div id="ad28fc7a-95a7-47e4-a6da-1da70d07c190" style="width:50%" class="column"><p id="218e8d0b-d382-4cbe-8886-4ea4163c3706" class=""><strong>Finding all connected subgraphs:
</strong><code>numConnected()</code> returns the number of connected subgraphs the given graph has</p><pre id="72d922bc-ec4d-4d85-97ee-772a6037ca49" class="code"><code>int numConnected(Graph g) {
    int subgraphID[GraphNumVertices(g)];
    for (int i = 0; i &lt; GraphNumVertices(g); i++) subgraphID[i] = -1;
    int numConnected = 0;
    for (int i = 0; i &lt; GraphNumVertices(g); i++) {
        if (subgraphID[i] == -1) {  // The current vertex hasn&#x27;t been marked as belonging to a connected subgraph
            dfsSetConnected(g, i, numConnected, subgraphID);
            numConnected++;
        }
    }
    return numConnected;
}

// Goes through every reachable vertex and marks them with an ID
void dfsSetConnected(Graph g, int start, int id, int subgraphID[]) {
    subgraphID[start] = id;
    for (int i = 0; i &lt; GraphNumVertices(g); i++) {
        if (GraphIsAdjacent(g, start, i) &amp;&amp; subgraphID[i] == -1) {
            dfsSetConnected(g, i, id, subgraphID);
        }
    }
}</code></pre></div><div id="01c6c04a-ddd9-40d2-b335-265f69683694" style="width:49.99999999999999%" class="column"><p id="e3eeb16c-4f3c-4e0c-bcd5-f83ff2a9fa6f" class=""><strong>Determining reachability:</strong>
Checks if a <code>dest</code> vertex is reachable from a <code>src</code> vertex:</p><pre id="32ca4796-9565-42dd-aee5-a23f67502ba9" class="code"><code>bool reachableDFS(Graph g, int src, int dest, bool visited[]) {
    if (src == dest) return true;  // Reached destination from some DFS path from src
    for (int i = 0; i &lt; GraphNumVertices(g); i++) {
        if (GraphIsAdjacent(g, src, i) &amp;&amp; visited[i] == false) {
            visited[i] = true;
            if (reachableDFS(g, i, dest, visited)) {
                return true;
            }
        }
    }
    return false;
}</code></pre><p id="44489202-b992-4187-987a-36e99bec1397" class="">
</p></div></div><div id="a4f459e2-8959-4664-b03a-c4a6c73b5858" class="column-list"><div id="eee50a00-b55e-46d8-aae9-a0bdeea53c1d" style="width:50%" class="column"><p id="77233e2f-83a0-4f4a-a9b2-43089947057f" class=""><strong>Eulerian Paths:
</strong>A path containing every edge exactly once. Allowed to visit vertices more than once</p><p id="06467068-f826-44bc-b8de-281154f913fb" class="">Could implement a brute force algorithm, but we know some important theorems:
<em>Theorem</em>. A graph has an <em>Euler circuit</em> iff it is connected with all vertices of even degree
<em>Theorem.</em> A graph has an <em>Euler path</em> iff it is connected and exactly two vertices are of odd degree</p><pre id="a61a9d18-f392-4326-b4ea-09976a8761a5" class="code"><code>// Assumes src != dest
bool hasEulerianPath(Graph g, int src, int dest) {
    if (numConnectedSubgraphs(g) &gt; 1) return false;  // Graph must be connected for an Euler path to exist
    if (degree(g, src) % 2 == 1 &amp;&amp; degree(g, dest) % 2 == 1) {
        for (int i = 0; i &lt; GraphNumVertices(g); i++) {
            if (i != src &amp;&amp; i != dest) {
                if (degree(g, i) % 2 == 1) {
                    return false;  // Return false since there exists some vertex with odd degree which is not the start or dest vertex 
                }
            }
        }
        return true;   
    }
    return false;
}</code></pre><p id="148129d1-6d00-47b1-b1bf-f5c10e49a8d1" class=""><em>Time-complexity:</em> O(V) — to check if all other vertices are of odd degree. This becomes O(V²) if getting the degree of a vertex requires looping</p><p id="e371bc5a-641c-42ce-bd98-17cbd1eb5d81" class="">
</p></div><div id="4e1f010f-fe73-4ce1-86ef-141517ceca05" style="width:50.000000000000014%" class="column"><p id="707dc358-74f7-4ffa-abdf-a9ccf95f9dca" class=""><strong>Hamiltonian Paths (brute force generate-and-test):
</strong>Requires brute force algorithm (no simpler algorithm known):  </p><ol id="02e5a7a2-d806-4f7e-ad58-722620b7f148" class="numbered-list" start="1"><li>Generate all simple paths from v to w (using dfs for example), </li></ol><ol id="0a91cce3-c110-4b44-bbf6-f5a7fa2318be" class="numbered-list" start="2"><li>Keep a counter of number of vertices visited for the current path,</li></ol><ol id="1e3823c3-7c0c-4c15-8d14-21e2d6305ee6" class="numbered-list" start="3"><li>Successful path has been found if this counter is equal to the total number of vertices. Otherwise unsuccessful if all simple paths have been exhausted</li></ol><pre id="f95fd68b-e63c-4fa0-bd4c-38c3ae181009" class="code"><code>bool hasHamiltonianPath(Graph g, int src, int dest) {
    bool visited[GraphNumVertices(g)];
    for (int i = 0; i &lt; GraphNumVertices(g); i++) visited[i] = false;
    return hamiltonR(g, src, dest, GraphNumVertices(g) - 1, visited);
}

bool hamiltonR(Graph g, int src, int dest, int dist, bool visited[]) {
    if (src == dest) {
        if (dist == 0) return true;
        else return false;
    }    
    else {
        visited[src] = true;
        for (int i = 0; i &lt; GraphNumVertices(g); i++) {
            if (GraphIsAdjacent(g, src, i) &amp;&amp; visited[i] == false) {
                if (hamiltonR(g, i, dest, dist - 1, visited)) {
                    return true;
                }
            }
        }
    }
    visited[src] = false;  // Set this vertex back to false, so we don&#x27;t avoid using it in the generation of other possible paths
    return false;   
}</code></pre><p id="790f9e80-2357-48bb-9a93-2dd8372b4e42" class=""><em>Time-complexity:</em> O((V-1)!) — since there could be (V-1)! paths to examine</p></div></div><h1 id="8ab1dd7e-e047-4300-a30c-a170cd58be04" class="block-color-blue_background">Week 6: Graphs II</h1><h3 id="5ad7ad87-f299-4cfb-aa67-8fc973a1c40c" class="block-color-teal_background">More on Graph Representation:</h3><div id="0b138417-8b72-46d3-b38a-f545d2b7ac0e" class="column-list"><div id="d04628e8-c5ac-4324-9a5f-9cbfc2ca542a" style="width:50%" class="column"><h3 id="2e2a8c31-ac7d-43cf-948d-21a6cd8958e8" class="">Directed Graphs:</h3><p id="1b8d45e0-94ea-48b4-b973-fe00d0ca0292" class="">Directed graphs can be represented with the same basic data structures, like an:
- Adjacency matrix — which is not necessarily symmetrical
- Adjacency list
- Array of edges — where the order of the two vertices encode direction</p><p id="3b4c58fc-28db-457e-ae01-9d4f63c763f4" class=""><strong>Transitive Closure Matrix and Reachability:
</strong>The transitive closure matrix records reachability and directed paths between vertices. With a matrix that records reachability, we can quickly access indexes and if <code>tcm[start][dest] == 1</code>, then we know that <code>dest</code> is reachable from <code>start</code>. </p><pre id="e027c79f-1af5-433e-b87d-e24df878348c" class="code"><code>int **transitiveClosureMatrix(Graph g) {
        // Setting up the matrix (needs to copy the graph&#x27;s adjacency matrix)
        int **tcm = malloc(sizeof(int) * g -&gt; numNodes);
        for (int i = 0; i &lt; g -&gt; numNodes; i++) {
                tcm[i] = malloc(sizeof(int) * g -&gt; numNodes);
                for (int j = 0; j &lt; g -&gt; numNodes; j++) {
                        tcm[i][j] = g -&gt; edges[i][j];  // Copies the elements of the graph&#x27;s adjacency matrix
                }
        }
        // Warshall&#x27;s algorithm:
        for (int i = 0; i &lt; g -&gt; numNodes; i++) {
                for (int j = 0; j &lt; g -&gt; numNodes; j++) {
                        for (int k = 0; k &lt; g -&gt; numNodes; k++) {
                                if (tcm[j][i] &amp;&amp; tcm[i][k]) {  // if j -&gt; i exists and i -&gt; k exists, then j -&gt; k must exist
                                        tcm[j][k] = 1;  
                                }
                        }
                }
        }
        return tcm;
}  // Very expensive to construct and store</code></pre><p id="6b2678a5-087e-43b0-a04f-f2f2a1b0e3d7" class="">Time-complexity: O(V³)
Space-complexity: O(V²)</p></div><div id="d5e54c89-d220-4f7f-a56d-76a6391bc308" style="width:50%" class="column"><h3 id="17faa547-92cd-4add-a880-1e89fb2a4216" class="">Weighted Graphs:</h3><p id="22d213ec-e532-4c56-88ba-8805f16ccef1" class=""><strong>Weighted graph representation:</strong>
Weighted graphs can be represented with the same basic data structures, like an:
- Adjacency matrix — where instead of on/off, we just have the weight value for connected vertices
- Adjacency list — where we add an extra field to the list nodes
- Array of edges — with 3-tuples for holding both vertices and the weight between them</p><p id="2ae55f12-19af-45f2-90c1-d61128fe500e" class=""><em>Possible struct declaration for a weighted edge:</em></p><pre id="06694c9e-0201-467a-9047-6be2b3a5b22d" class="code"><code>typedef struct Edge {
        Vertex v;
        Vertex w;
        int weight;
} Edge;</code></pre><p id="a5cca4f9-d95c-46f9-952b-b593d1402f6a" class=""><em>Representation with an adjacency matrix:</em></p><pre id="5c34f3d7-6a56-4ab5-91d0-35428ddc6f8e" class="code"><code>typedef struct GraphRep {
        int **edges;  // Adjacency matrix storing intger weights
        int nV;
        int nE;
} GraphRep;

void insertEdge(GraphRep G, Edge e) {
        if (g -&gt; edges[e.v][e.w] == 0) {  // Then there is no edge recorded between v and w
                g -&gt; edges[e.v][e.w] = e.weight;
                g -&gt; edges[e.w][e.v] = e.weight;
                g -&gt; nE++;
        }		
}</code></pre></div></div><h3 id="0b9b6fa5-0ca1-4c6c-a31e-e3e4a8209100" class="block-color-red_background">Graph Spanning Tree Algorithms:</h3><div id="9ce8ea5b-c5a0-4ad1-9633-5f8f20b9e207" class="column-list"><div id="dbc1abdc-c9a5-4bc5-bc5f-085c085223c6" style="width:50%" class="column"><p id="94fee605-2b4e-44a2-853c-0f6fa011bffe" class=""><strong>Kruskal&#x27;s Algorithm:</strong>
We could find minimum spanning trees via a brute-force generate-and-test algorithm which examines every spanning tree and returns the one with the best cost. Or we can apply <em>Kruskal&#x27;s algorithm</em>:
Start with all vertices and no edges → sort all edges in ascending order → add edges from smallest weight upwards, skipping edges that introduce a cycle and stopping if we achieve a conencted graph</p><pre id="2933c273-de95-4756-9509-b7d384e56d0d" class="code"><code>Graph kruskal(Graph g) {
        Graph MST = newGraph();
        // 1. Get an ascending list of the cheapest weights
        Edge edges[g -&gt; numNodes];
        copyEdges(edges, g);  // Copy the edges over
        sortAscending(edges);		
        // 2. Add them one by one, each time checking if we&#x27;ve introduced a cycle or if we&#x27;re done
        for (int i = 0; i &lt; g -&gt; numNodes; i++) {
                insertEdge(MST, edges[i]);
                if (hasCycle(MST)) {
                        removeEdge(MST, edges[i]);
                }
                if (MST -&gt; numNodes == g -&gt; numNodes) {
                        break;  
                }
        }
        return MST;
}</code></pre><p id="9d974c1a-8e19-4fc4-be46-cf39a571a379" class="">Time-complexity: hard to estimate — the edge sorting could be O(E²) or O(ElogE) and the cycle checking could be O(V+E) if we use a DFS cycle checking algorithm</p><p id="af412eec-0f95-4d4d-a1df-ad16ef9473e0" class="">
</p><p id="d02b3b5e-0182-4164-b916-11262b3e253d" class=""><strong>Prim&#x27;s algorithm:</strong></p><ol id="b776609e-a624-4b32-b795-6ce436daeb00" class="numbered-list" start="1"><li>Start from any vertex <code>src</code> and with an empty MST</li></ol><ol id="4dfd0364-f865-4152-bda4-18f4835e3518" class="numbered-list" start="2"><li>Consider all neighbours of all vertices in the <em>current MST </em>which won&#x27;t introduce cycles. Pick the cheapest edge of the considered edges. Repeat until all vertices have been added</li></ol><p id="5e863c3f-edce-4dc3-b6c3-7a15f7b49d2b" class="">Note: a priority queue helps this algorithm select the best edge. For a priority queues, the first element that is dequeued is the one that has the highest <em>priority </em>value, so in this case, the lowest weight corresponds to the highest priority</p><p id="a2d1a012-36aa-42a7-b7c6-0565c4b879f9" class="">
</p></div><div id="92490f63-7f0b-4f2d-836a-b3e821f8ec92" style="width:50%" class="column"><p id="418b2142-2a29-4333-9e53-266b5f37d2df" class=""><strong>Dijkstra&#x27;s Algorithm: </strong><strong>
</strong>Uses a <code>dist[]</code> array to keep track of shortest distances recorded and uses a <code>pred[]</code> array so we can trace the actual shortest path</p><p id="9125e8c7-03f2-4bd4-b27f-d815b2236bd4" class=""><em>Edge relaxation:</em> a function that updates the shortest distance to a certain dest node. 
Pretty much just: <code>if (dist[v] + weight &lt; dist[w]) { dist[w] = dist[v] + weight; pred[w] = v; }</code></p><pre id="ed8865d0-7926-4c8b-9cf3-f395cd35b103" class="code"><code>dist[]
pred[]

def dijkstra(G, start):
        set all dist to ∞, set dist[start] = 0 
        set all pred to -1
        vertexSet = all vertices of G
        while vertexSet not empty:
                find some vertex s in vertextSet with minimum dist[s]   # We can use a priority queue here to achieve O(E + Vlog(V))
                for each (s, t, w) in edges of G:
                        relax along (s, t, w)  
                vertextSet = vertexSet \ {s}  # Means remove s from vertexSet</code></pre><p id="2668a345-17e6-46d1-acf6-5763d6dfbfd3" class=""><em>Time-complexity:</em> O(E + V²) — each edge needs to be considered once, and the outer loop has O(V) iterations... Apparently the overall cost is O(E + V²), and the best known implementation using a priority queue gets O(E + Vlog(V))</p><p id="1bea7a66-b32d-4d0b-b9ad-e9cfcef98157" class="">
</p></div></div><h1 id="e71066e2-7249-4a94-a21f-111fcea411ac" class="block-color-blue_background">Week 7: Heaps and Hashing</h1><h3 id="bce3caa6-7ebe-4a72-84cb-8627a3802a70" class="block-color-teal_background">Heaps:</h3><div id="726a1bc1-572a-401d-a473-f006cf98a96b" class="column-list"><div id="2bb336c7-130a-473e-a760-26bec714ddde" style="width:50%" class="column"><ul id="4cd1a041-367c-4184-b9f8-c1857a94ca18" class="bulleted-list"><li>Heaps can be viewed as binary trees with top-down ordering. </li></ul><ul id="41059e5f-013a-44e8-9d6b-50f28b19853e" class="bulleted-list"><li>A <em>min heap</em> has its root node as its minimal value, so every level below increases in value
A <em>max heap </em>has its root node as the maximal value, so every level below it decreases in value</li></ul><ul id="42bcef7b-caf5-47ff-894e-51f1daa71d82" class="bulleted-list"><li>Heaps are implementable by an array (if we know the size), since we know where the index of the left and right child are</li></ul><ul id="020fdce4-25fd-425b-8a60-001d905c03ce" class="bulleted-list"><li>Heaps are a useful underlying structure for implementing priority queues, since higher priority nodes will be at the top of the heap</li></ul><ul id="75b46893-b491-4e25-a2bf-b92a2660b2ca" class="bulleted-list"><li>Insertion always occurs at a leaf node with the next unoccupied index, and is bubbled to the right place by a series of swaps with the parent</li></ul><ul id="881ba78d-92b1-4761-85d2-8cc83f2c7926" class="bulleted-list"><li>Deletion always occurs at the roots, which makes sense for a priority queue&#x27;s dequeue function. When the root is deleted, it it replaced by the element at the last occupied index and then that element gets bubbled down to its right place by a series of swaps with the left child</li></ul><p id="68629d3e-179f-44aa-b271-9774696f98cf" class="">
</p><p id="7e253072-2f10-4ba8-9e6f-c3bd2f4c4e3d" class="">Suppose our current node has index <code>i</code>:</p><ul id="b89dad0c-c5a2-40d0-8832-49af92e8797a" class="bulleted-list"><li>The left child is at index <code>2i</code></li></ul><ul id="6fcb1a93-d522-4b6e-b4db-63b3404747dc" class="bulleted-list"><li>The right child is at index <code>2i + 1</code></li></ul><ul id="aa8b07c6-3d0b-4672-a71d-c67b1017a41c" class="bulleted-list"><li>The parent is at index <code>floor(i/2)</code></li></ul><p id="fa1523d3-05a9-4fb8-a212-d2f073ea8503" class=""><em>Heap indexing:
</em>Goes left to right, top to down across each level. The next free index for insertion would be the lower-most left-most unoccupied leaf node
Heap indexing actually starts at 1, not 0</p><figure id="55c766e2-1dba-4deb-8cf2-79d6b428f83a" class="image"><a href="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%2011.png"><img style="width:480px" src="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%2011.png"/></a></figure><p id="b98d037e-4097-498f-8cbd-5cb2a9c8279b" class="">
</p><p id="63170ad3-2d6b-4a40-b0bd-b38f4033c3ce" class=""><em>Possible struct declaration:</em></p><pre id="f7612001-a173-4155-b452-bfd74b8d1497" class="code"><code>typedef struct heapRep *Heap;
struct heapRep {
        int *nodes;
        int currSize;
        int maxSize;
};</code></pre></div><div id="4fc1882d-7a82-4ec9-86e6-a9b10373e787" style="width:50%" class="column"><p id="a004d5a2-14b8-429a-978e-d093a65d7a3f" class=""><em>Possible implementation:</em> </p><pre id="9a940e67-dd6d-4be5-8949-7e46d6ef2b19" class="code"><code>Heap newHeap (int size) {
        Heap heap = malloc(sizeof (struct heapRep));
        int *items = malloc(sizeof(int) * (size + 1));  // size + 1, so our index range becomes 1 -&gt; N, not 0 -&gt; (N-1). This is because heaps are indexed starting from 1
        heap -&gt; nodes = items;
        heap -&gt; currSize = 0;
        heap -&gt; maxSize = size;		
}

// Inserts at the next free array slot, then bubbles it up to the right position in the heap by a series of swaps with the parent node
void insertInHeap(Heap heap, int value) {
        heap -&gt; currSize++;
        int i = heap -&gt; currSize;
        heap -&gt; nodes[i] = value;
        while (i &gt; 1 &amp;&amp; a[i] &lt; a[i / 2]) {  // If the parent is greater than the child, swap the child and parent (since greater values are at the top)
                int tmp = a[i / 2];  
                a[i / 2] = a[i];
                a[i] = tmp;
                i /= 2;
        }
}

// Pops the root node, replaces the root node with the last indexed node and bubbles it down to the right place
int popHeap(Heap heap) {
        int top = heap -&gt; nodes[1];
        heap -&gt; nodes[1] = heap -&gt; nodes[heap -&gt; currSize];  // Delete the root everytime 
        heap -&gt; currSize--;
        int i = 1;
        while (2 * i &lt;= heap -&gt; maxSize) {
                int curr = heap -&gt; nodes[i];
                int j = 2 * i;
                if (j &lt; N &amp;&amp; a[j] &lt; a[j + 1]) j++;  // Pick the larger child for swapping
                if (a[j] &gt;= curr) {
                        int tmp = j;
                        heap -&gt; nodes[j] = heap -&gt; nodes[i];
                        heap -&gt; nodes[i] = heap -&gt; nodes[tmp];
                }
                i *= 2;
        }
        return top;
}</code></pre><p id="8d72f583-8b6e-4411-b858-ff6c23171ce9" class="">Time-complexities:</p><ul id="dce95d58-74a2-4b57-9d6b-06f7782e2db1" class="bulleted-list"><li>Insertion: O(logn) — requires bubbling up the leaf node to the right place across up to <code>n</code> levels</li></ul><ul id="d12f33de-b128-47cf-a87e-885cf1ec5910" class="bulleted-list"><li>Deletion: O(logn) — requires bubbling the root node down to the right place across <code>n</code> levels</li></ul></div></div><h3 id="70dfc310-6c78-4fb1-8562-984595b9a12b" class="block-color-teal_background">Hashing:</h3><div id="99b9a6f2-944e-4eaa-82a1-178b1a083c4d" class="column-list"><div id="31b078e6-8b5b-446f-85a1-dc9f09f1c52b" style="width:50%" class="column"><p id="b132ae05-2cdc-43fb-9b87-f2eb0703089f" class="">A hash table associates a key with a hash function value which is associated to a specific index in an array like data structure. This allows for very quick key-value lookups which would otherwise take O(n) or O(logn) with an array search algorithm. Hashing is used widely in database systems.</p><ul id="094abff3-f0df-408c-a28d-e9d639704e75" class="bulleted-list"><li>A hash tables is basically a primitive array data structure that allows arbitrary key types (like strings, instead of integer indexes), eg. <code>course[&quot;COMP3311&quot;]  == &quot;Database systems&quot;</code></li></ul><ul id="05f69083-4e75-4d33-ae26-2957ef015100" class="bulleted-list"><li>A hash function — <em>h: key → [0, N-1]</em>, maps a given key to a hash function value which is an index into a hash table. This index into the hash table is calculated using the input itself</li></ul><ul id="cfcd8f97-6361-4563-8af1-309e5f2c81bd" class="bulleted-list"><li>We can lookup a value in an array in O(1), provided that we know which index it is at. If we didn&#x27;t then we would need a O(n) or O(logn) search algorithm.
With a hash table, we don&#x27;t need to know which index of the table the value we want to fetch is at. We can just pass a key through a hash function that returns an index into the hash table which is roughly where we can expect to find our target value, and then perform a very short scan from there on. Sometimes lookups can be immediate</li></ul><ul id="d04363d8-a939-473f-9682-deaca31079b5" class="bulleted-list"><li>Collision resolution: the range of the hash function <em>[0, N-1]</em> may be smaller than the set of <em>keys</em> , so by the pigeonhole principle, the hash function could map different keys to the same hash value. There are different strategies for handling these collisions: separate chaining or linear, quadratic and double hash probing</li></ul><p id="68ba2aa6-7185-47ef-a266-9c71a7ff646a" class="">
</p><p id="3b0f5c1e-1c24-4a49-888c-a169cb838cd4" class="">Problems with hashing:</p><ul id="c47fce23-c763-4fa5-8028-3910ef93275a" class="bulleted-list"><li>The hash function uses the hash table&#x27;s size in its computation, so we can&#x27;t expand the size of the hash table without having to recompute and reinsert all existing entries</li></ul><ul id="c596d30a-9895-4fcb-8330-c7a2b3783b47" class="bulleted-list"><li>Items are stored in unpredictable order</li></ul></div><div id="84582ae1-6f30-47e3-ba23-473f69aca499" style="width:50%" class="column"><p id="6488be9e-b93a-44e8-9c3b-68052c6a200e" class=""><em>Possible struct declaration:</em></p><pre id="5a0dea80-ea21-4814-9a6b-08e0afb66779" class="code"><code>#define EMPTY_SLOT -1

typedef struct hashTableRep *HashTable
struct hashTableRep {
        Item **items;  // Array of Item pointers, where the &#x27;Item&#x27; data type could be a struct containing some fields
        int currSize;  // Current number of entries in the hash table
        int N;         // Array size. The hash function should map keys to a value within [0, N - 1]
};</code></pre><p id="a7278442-cbaf-4e22-a68b-633f62575b9d" class=""><em>Basic function prototypes:</em></p><pre id="26bf2011-fd8e-490c-be9b-582a82a26101" class="code"><code>typedef struct HashTabRep *HashTable;
HashTable newHashTable(int size);             
Item *search(HashTable hashtab, Item key);          // Find item with specified key
void insert(HashTable hashtab, Item item);          // Add a new item to the hash table
void delete(HashTable hashtab, Item target);        // Delete a target entry from the hash table</code></pre></div></div><hr id="7ed75252-e567-4f70-8e55-ceed932e9969"/><div id="87a0224a-1681-45ae-a59f-a587ee80a8f3" class="column-list"><div id="50977c19-8ea7-4cb8-b35e-ebfbe027027c" style="width:50%" class="column"><p id="9d8a75ff-9c9e-422e-929b-0b502ed5cfc0" class=""><strong>Hash Functions:
</strong><em>Very basic hash function for string keys:</em></p><pre id="a7fa25f1-08ac-47e5-b81a-c238ebfc1771" class="code"><code>int hash(char *key, int N) {  // The &#x27;Key&#x27; type in this example is a string
        int val = strlen(key);
        return val % N;  // Use mod function to map any integer to another integer within the range [0, N-1]
}</code></pre><p id="59b75fd0-445e-46e3-90d9-42e8c6e9eb4e" class="">There are a ridiculous number of deficiencies with this hash function. A better hash function would introduce some randomness to make the output a bit more unique so as to minimise collisions.</p></div><div id="2600001f-fa9b-4057-ac24-8a4b16089c74" style="width:50%" class="column"><p id="6f1c0fa8-3711-4114-956f-2f2f448af1cb" class="">
<em>&#x27;Universal&#x27; hashing:
</em>Tends to return a more unique hash function value, so the output is more reasonably distributed across the indexes in [0, N-1], therefore minimising collisions</p><pre id="bebbae33-9040-461c-ab2a-40c9c831e7d1" class="code"><code>int hash(char *key, int N) {
        int a = 31415;  // Prime numbers. These are better for introducing unpredictability than non-primes
        int b = 21783;
        int val = 0;
        char *c;
        for (c = key; c != &#x27;\0&#x27;; c++) {
                a = (a * b) % (N - 1);
                val = (a * h + *c) &amp; N;
        }
        return val;
}</code></pre></div></div><hr id="55282b19-5888-4ff1-b8a7-99c0a760f457"/><p id="51e357cf-7c06-4db2-ac58-169b350b62e3" class=""><strong>Collision Handling:</strong></p><ul id="2b18f596-54ab-42ae-89c5-ed2ab80b6879" class="bulleted-list"><li>Chaining — make each cell of the hash table point to a linked list of records that share the same hash function value</li></ul><ul id="b481e94a-95c6-4825-8834-94bc1fbd8430" class="bulleted-list"><li>Open addressing — the item is inserted to the next available cell
→ <em>Linear probing:</em> if the index of the array is occupied, then use a linear search algorithm to find the next available cell and place it there, wrapping around to the start of the array if necessary. When retrieving the value, we perform a linear search from the point we expected it to be, but which was occupied
→ <em>Quadratic probing:</em> scans from the mapped value onwards but takes quadratic steps each time instead of one by one like for linear probing
→ <em>Double hashing:</em> uses a second hash function to calculate how many steps to jump</li></ul><div id="0a3f637e-bc19-49d1-a36d-119abd420694" class="column-list"><div id="097e07ce-8bea-4f71-9865-1dd8436cfc35" style="width:25%" class="column"><p id="6db5314e-4557-48ce-9d5b-dbf74a772b1a" class=""><em>Separate Chaining:</em>
The hash table becomes an array of linked list heads which stores all the entries that have the same function value</p><p id="8d7fe4c5-ec52-40b8-ad7f-e0a36c665e40" class=""><em>Possible struct declaration to set up separate chaining:</em></p><pre id="d750ea0a-57c6-4342-9138-545a3ee8d515" class="code"><code>typedef struct HashTabRep {
    List *lists;    // array of Lists of Items
    int  currSize;  // Number of items stored in HashTable
    int  N;         // Slots in the array
} HashTabRep;</code></pre><ul id="7cad9309-1957-484c-a9a1-cfdb4876c5d1" class="bulleted-list"><li>Insertion — pass key into hash function → insert into the linked list at <code>hashtab → lists[hashVal]</code> </li></ul><ul id="8a901c41-1285-43f2-b2e6-345b740be5f3" class="bulleted-list"><li>Search — pass key into hash function → search in linked list at <code>hashtab → lists[hashVal]</code> </li></ul><ul id="3132a579-a377-4290-b006-fa163fe38752" class="bulleted-list"><li>Deletion — pass key into hash function → delete in linked list at <code>hashtab → lists[hashVal]</code> </li></ul><p id="328c21aa-7663-4be2-93e7-20be2538f820" class="">Time-complexity: O(M) — where M is the number of entries. All entries could be stuffed into a single linked list at the same hash table index</p><p id="39a10181-3bf4-4299-bb4b-6fb65f1e92d0" class="">
</p></div><div id="723186d6-3918-492e-8e5a-e7c69e2a430c" style="width:37.50000000000001%" class="column"><p id="9022d927-b004-43f9-bd22-007a63c39670" class=""><em>Linear probing:</em>
If the hash table index is occupied, just perform a linear scan onwards for the next free slot</p><pre id="43dbbb9b-b9f2-4cc4-84c0-88da93556af1" class="code"><code>void insert(HashTable hashtab, Item item) {
        int N = hashtab -&gt; N;
        int insertIndex = 0;
        int k = hash(item, N);
        for (int i = 0; i &lt; N; i++) {
                insertIndex = (k + i) % N;   // Search starting from the hash function value index, wrapping around the array if necessary
                if (hashtab -&gt; items[insertIndex] == EMPTY_SLOT) break;  // Free slot found
                if (hashtab -&gt; items[insertIndex] == item) break;        // Item already exists
        }
        if (a[insertIndex] == EMPTY_SLOT) {
                hashtab -&gt; currSize++;
                hashtab -&gt; items[insertIndex] = item;
        }
}</code></pre><p id="4a70b658-fbd7-4eca-a901-36ef2be2587e" class="">Time-complexity: O(M) — the search and delete functions would land on the hash index and then perform a linear scan until the target is found
Note: the <code>search()</code> and <code>delete()</code> functions stop when it reaches an <code>EMPTY_SLOT</code> that <em>has not been in use before</em>. There could be <code>EMPTY_SLOTS</code> between the landing index and where the target is if we have deleted entries between them at some point after the target was inserted. This means we need some sort of way to identify that the slot is empty but has been used before, and therefore shouldn&#x27;t signal our scanning to stop.</p><p id="eb9d3dac-e9da-44b0-bb5f-3bd31135535b" class="">
</p><p id="a66b8784-b8aa-47f1-902d-f19f29a7ffc9" class=""><em>Quadratic probing:</em>
Like linear probing, but instead of searching in jumps of 1, make jumps of 1, 4, 9, etc.</p></div><div id="0b86f3e1-9e89-4769-afcd-4a5111ee89bb" style="width:37.50000000000001%" class="column"><p id="53da13b7-9504-448c-bd89-6e04a5f1b21a" class=""><em>Double hashing:</em>
Like quadratic probing, but makes a more calculated jump which is determined by a second hash function</p><pre id="ae3c6e2b-8b3f-454c-8acb-8ddd8f822421" class="code"><code>typedef struct hashTableRep *HashTable
struct hashTableRep {
        Item *items;  
        int currSize;  
        int N;         // Array size
        int N2;        // A modulo operand we can use for our second hash function. This should be set in the newHashTable function
};</code></pre><pre id="c41b7471-e625-4b6b-b1a6-6c488ca251c1" class="code"><code>void insert(HashTable hashtab, Item item) {
        int N = hashtab -&gt; N;
        int insertIndex = 0;
        int k = hash(item, N);
        int jump = hash2(item, hashtab -&gt; N2);
        for (int i = 0; i &lt; N; i += jump) {  // Incremement by the hash2 function value
                insertIndex = (k + i) % N;
                if (hashtab -&gt; items[insertIndex] == EMPTY_SLOT) break;
                if (hashtab -&gt; items[insertIndex] == item) break;
        }	
        if (hashtab -&gt; items[insertIndex] == EMPTY_SLOT) {
                hashtab -&gt; currSize++;
                hashtab -&gt; items[insertIndex] = item;
        }
}</code></pre><p id="c67f535c-c480-44f7-8674-79f6e7ee4ff3" class="">The second has function hash2: key → [1, N2 - 1]</p><p id="00b3973b-fb34-4fa6-9a3b-1fd48cf58fb1" class="">
</p><p id="5091fa38-2e08-4065-abcf-5e8f076b7624" class="">The amount we increment must ensure that all <em>elements are visitable</em>. We can pick an increment number that is coprime with <code>N</code> to ensure this. 
When we&#x27;re creating the table for the first time, it&#x27;s smart to pick a prime number size so our <code>hash2()</code> function values will be suitable to use for probing.</p></div></div><hr id="9e7a56b1-b8e4-4ab9-8342-13ce4b25b50f"/><p id="091154b6-2c10-4693-a05c-8089a7323bfa" class="">Performance of insertion, search and deletion when there are collisions:</p><ul id="9d326cde-505c-4af8-a41a-cf88eb318d05" class="bulleted-list"><li>When we are scanning the array from the mapped value onwards, performance depends on the <em>load factor</em> <code>α = M / N</code> which is a measure of how &#x27;full&#x27; the hashtable is.
As α → 1, unsuccessful searches make the search algorithm very expensive since almost the whole table would have to be scanned before the function can say with certainty that the target element does not exist</li></ul><ul id="05a9ae51-9d37-46a8-ab53-5f5056d1033c" class="bulleted-list"><li>With linear probing, unsuccessful search is very expensive. 
With quadratic probing and double hashing, unsuccessful search is substantially less expensive</li></ul><h1 id="f92d6d65-ac83-45b4-9d97-14f7c197b880" class="block-color-blue_background">Week 8: Sorting Algorithms</h1><h2 id="7e69ac5a-0f69-4323-b078-521a0d596449" class="block-color-teal_background">Sorting:</h2><p id="bfdb06c5-6a1e-45a2-9941-8b8de785e496" class="">Sorting involves arranging a collection of items in order, based on some property of the items. This is an important problem because sorted collections allow better search algorithms to be implemented as well as other algorithms like duplicate detection, etc.</p><ul id="595f55ae-b851-4f2c-94da-4a7361f8d088" class="bulleted-list"><li><em>Stable sorting algorithms:</em> if two elements are identical with x occurring before y in the input, the ordered output will also have x occurring before y</li></ul><ul id="f0c166a7-c18b-47ed-9923-8dd9a7d4f1cf" class="bulleted-list"><li><em>Adaptive sorting algorithms:</em> can analyse the input sequence and adopt the sorting strategy which is most suitable. For example, if the input array was already sorted, then the adaptive sorting algorithm will recognise that and just return the original input without doing unnecessary work</li></ul><ul id="4a6e30a0-6517-403b-89ab-36e5c06fffda" class="bulleted-list"><li>Main sorting algorithms:<ul id="8533a8c3-0cde-434b-b417-1565e1456a22" class="bulleted-list"><li>Selection sort </li></ul><ul id="9eb597b8-baf4-43af-9a82-4fbd4f951b41" class="bulleted-list"><li>Bubble sort </li></ul><ul id="9c44a1da-3040-4f58-b98e-051026ce1c69" class="bulleted-list"><li>Insertion sort </li></ul><ul id="fd7c8427-93ab-4b63-a320-0fb5aaa8ebd9" class="bulleted-list"><li>Shell sort </li></ul><ul id="e2013832-37b3-4d82-9575-54374cb6e47a" class="bulleted-list"><li>Quick sort </li></ul><ul id="ae120355-d719-468e-a11e-3e7a1f9ae9fe" class="bulleted-list"><li>Merge sort </li></ul><ul id="58a62673-4e61-4c89-98fa-0da648b6873a" class="bulleted-list"><li>Heap sort </li></ul><ul id="f71ce876-f0d9-4a6d-b75d-30e35607c6f8" class="bulleted-list"><li>Radix sort </li></ul><ul id="0a32ba4f-fcee-40f8-abd4-f3f6c3685443" class="bulleted-list"><li>Bucket sort </li></ul><ul id="74ff3131-04f0-4fdc-8881-610786491aa1" class="bulleted-list"><li>External mergesort </li></ul></li></ul><ul id="c9049104-f289-4aeb-aadc-9066bde9186d" class="bulleted-list"><li><code>qsort(array, n, size, int (*cmpFunc)())</code> from <code>stdlib</code> sorts any kind of array, containing <code>n</code> items of <code>size</code> byte, if we supply the appropriate function pointer for comparison operations.</li></ul><p id="62c57069-a42b-4e8b-a662-50db2920b1b6" class="">
</p><hr id="4c2e7394-4bf0-45c6-8fdc-5b569ca8656d"/><h3 id="e539d6b5-5412-48f1-8f5a-28cf0a29abad" class="block-color-red_background">Comparison Sorting Algorithms:</h3><div id="a5965ac3-efc4-414b-9d5c-e4c3b6f319ff" class="column-list"><div id="d50d7a23-b53e-4f23-ba52-f1be9f979434" style="width:50%" class="column"><p id="9de228f0-f79f-4ac1-af7e-bab8bd6113a4" class=""><strong>Selection sort:</strong> 
<em>Logic:</em> find min, swap it with what&#x27;s in the zeroeth index of the array, then find the next smallest and place it in first index, and so on</p><ul id="7da9029c-2054-4e0e-b5ed-9fa1435bdcad" class="bulleted-list"><li>Grows from left to right</li></ul><ul id="7a102e87-5893-49ae-9212-c3fbd226bc89" class="bulleted-list"><li>Stability depends on implementation. Not adaptive</li></ul><pre id="3f1212c9-c39d-400e-a4ff-8f14d51c2b27" class="code"><code>// Sorts to ascending order
void selectionSort(int input[], int lo, int hi) {
    for (int i = lo; i &lt; hi - 1; i++) {
        int min = i;
        for (int j = i + 1; j &lt; hi; j++) {  // Start scanning the unsorted segment for the minimum value
            if (input[j] &lt; input[min]) {
                min = j;
            }
        }
        swap(input, i, min);
    }
}</code></pre><p id="14deef4b-0163-452e-98b3-aaaf617cc089" class=""><em>Time-complexity:</em> O(n²)  — max total comparisons given by: <code>(n-1) + (n-2) + ... + 1 = n(n + 1)/2</code>, total swaps given by: <code>n-1</code>
In both best and worst cases, we&#x27;re still making the same number of comparisons to identify the mininimum each iteration</p><figure id="f25ba228-85d8-447c-8435-a83bdfa43fb3" class="image"><a href="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%2012.png"><img style="width:288px" src="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%2012.png"/></a></figure><p id="3c7e05d3-0007-46ea-b21f-199ad1c004a3" class=""><em>Swap function:</em></p><pre id="65ce0c9b-f59d-4c79-b906-964501361c3e" class="code"><code>void swap (int input[], int i, int j) {
    int tmp = input[j];
    input[j] = input[i];
    input[i] = tmp;
}</code></pre></div><div id="a93aafd6-17e0-4bf2-9d9e-5a7d786e7a12" style="width:50%" class="column"><p id="5e438a8c-3eb0-4992-8639-368eaef3454a" class=""><strong>Bubble sort:</strong> 
<em>Logic:</em> looks at adjacent items and swaps if out of order, bubbling the item up
When the element being bubbled encounters an element it should swap with, that other element becomes the one being bubbled. Doing this <code>n</code> times across the whole array results in a sorted array</p><ul id="d0b5bfb3-d4f1-4d70-8e96-d51f1773836e" class="bulleted-list"><li>Grows from left to right, with the max item encountered being bubbled to the far right</li></ul><ul id="db4758f9-5fab-4922-9971-60c7a195e2c7" class="bulleted-list"><li>Can be stable and adaptive, because it can check if the array is already sorted</li></ul><pre id="0cdea020-b0ff-4c43-914d-d50943aab6e5" class="code"><code>// Sorts to ascending order
void bubbleSort(int input[], int lo, int hi) {
    for (int i = lo; i &lt; hi; i++) {
                int swaps = 0;
                for (int j = hi - 1; j &gt; i; j--) {
                    if (input[j] &lt; input[j - 1]) {
                        swap(input, j, j - 1);
                                        swaps++;
                    }
                }
                if (swaps == 0) break;  // Since the array was scanned and no swaps were made, the array must be sorted, so break
    }
}</code></pre><p id="31c8f941-76d9-4aad-b42e-e48fa5075672" class=""><em>Time-complexity:</em> O(n²) 
Best case: the array is already sorted, so just 1 + 1 + ... + 1 comparisons (n)
Worst case: the array is reverse sorted, so (n-1) + (n-2) + ... + 1 = </p><figure id="2a1c844f-14f1-4bce-bc17-e442535a5786" class="image"><a href="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%2013.png"><img style="width:288px" src="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%2013.png"/></a></figure></div></div><div id="68a94ad2-6a1b-43f8-b4ed-ea50b9092e7e" class="column-list"><div id="2c040fa5-4c76-4c9d-887c-b3d7fab11baa" style="width:50%" class="column"><p id="3e07055c-f541-492a-8a52-c274732988c0" class=""><strong>Insertion sort:</strong>
<em>Logic: </em>on each iteration, consider the element right next to the sorted segment. Bubble that element to the right place within the sorted array by comparing with elements in the already sorted segment.</p><ul id="3a620848-285c-4ef8-b1ac-24234231023c" class="bulleted-list"><li>Grows from left to right, considering elements directly next to the end of the sorted array.</li></ul><ul id="b62edf7e-13f7-40f0-8e6f-4f956438ccc2" class="bulleted-list"><li>Stability depends on implementation, adaptive if it stops scanning when the position is found</li></ul><pre id="2558558a-ddc0-453e-96a7-726ca8a65da5" class="code"><code>// Sorts to ascending order
void insertionSort(int input[], int lo, int hi) {
    for (int i = lo; i &lt; hi; i++) {
        for (int j = lo; j &lt; i; j++) {
            if (input[i] &lt; input[j]) {
                swap(input, i, j);  // Bubble it to the right place in the sorted segment
            }
        }
    }
}</code></pre><p id="22d43046-02bd-47d2-987e-50114a804abd" class=""><em>Time-complexity:</em> O(n²)
Best case: the array is already sorted, so we just have 1 + 1 + ... + 1 comparisons (n)
Worst case: the array is reverse sorted, so we have a growing number of comparisons to find where to insert the new element in the sorted segment (same as for selection sort: <code>n(n+1)/2</code>)</p><figure id="f7f1e010-d464-40f8-8b33-d0e56db2867c" class="image"><a href="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%2014.png"><img style="width:192px" src="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%2014.png"/></a></figure></div><div id="20c74790-0f73-46d4-a896-742290f68f38" style="width:50.000000000000014%" class="column"><p id="f50b6451-4681-4dc7-bf85-2f9bfd5e96a0" class=""><strong>Shell sort</strong><strong>:
</strong>Also known as <em>h-sorting, </em>which is an improvement on insertion sort.
A 3-sorted array means that if we take elements <code>array[0]</code>, <code>array[3]</code>, <code>array[6]</code>, ..., they will be in order.
A 2-sorted array means that if we take elements <code>array[0]</code>, <code>array[2]</code>, <code>array[4]</code>, ..., they will be in order.
A 1-sorted array means that the array is sorted
Algorithm uses a characteristic sequence of <em>h-values</em>. Such sequences are determined empirically, for example 1093, 364, 121, 40, 13, 4, 1, or something else</p><pre id="fd4a39e7-7f8a-47bf-a667-9f2a2e9b9e5f" class="code"><code>// Sorts to ascending order
void shellSort(int a[], int lo, int hi) {
        int hValues[8] = {701, 301, 132, 57, 23, 10, 4, 1}
        for (int i = 0; i &lt; 8; i++) {
                int h = hValues[i];
                int start = h + lo;
                for (int n = start; n &lt; hi, n++) {
                        int value = a[n];
                        for (int k = n; k &gt;= start &amp;&amp; value &lt; a[k - h]; k -= h) {
                                move(a, k, k - h);
                        }
                        a[k] = value;
                }
        }
}</code></pre><p id="5376af50-ad70-45c2-b144-991696c09d6b" class="">Efficiency depends on the h-values used, which we can achieve O(n^(3/2)) with, or even better with the right sequence.  Shell sort has not yet been fully analysed.</p></div></div><div id="1b39fb98-3cba-4188-bfa3-42cf10b920e5" class="column-list"><div id="7c06a026-35e4-4d9e-8f74-98048ac6c4b9" style="width:68.75%" class="column"><p id="5b1b495a-04be-4a21-9d07-face8fa8efd4" class=""><strong>Quick sort (</strong><strong>recursive):</strong></p><p id="df8884ea-828f-45fe-90d1-caf1b41cf620" class=""><em>Logic:</em> pick a pivot element, then sort the array such that everything to the left of that pivot is less than it while everything to the right is greater than it, and then start sorting left and right by the same function.</p><ul id="7880c695-2bfd-4398-a4e0-811cb33b3d58" class="bulleted-list"><li>Usually not stable and not adaptive </li></ul><pre id="25fdea6f-b995-408f-bf67-3713bdf3f281" class="code"><code>// Sorts to ascending order
void quickSort(int input[], int lo, int hi) {
        if (lo &gt;= hi) return;              // Terminating case
        int i = partition(input, lo, hi);  // Partition returns the index of where the pivot element input[lo] belongs 
        quickSort(input, lo, i - 1);       // Sort the unsorted left segment
        quickSort(input, i + 1, hi);       // Sort the unsorted right segment
}</code></pre><p id="8d99c865-091e-4f53-9b43-72826f30c6a5" class="">In the partition function, we are finding the right spot to place the pivot element and swapping elements from left and right segments so that everything to the left of the pivot is less than it and everything to the right is greater than it
1. Scan from the left, if the pivot encounters something greater than it, stop
2. Scan from right, if the pivot encounters something less than it, stop
3. Swap the elements which caused scanning to stop
4. Continue the scanning from left, then scanning from right and swapping. 
5. Stop when the left and right scanners cross each other
6. Swap the pivot element with where this intersection occurred</p><pre id="2ab91fca-e8a1-4330-80e2-61cb1dd49775" class="code"><code>// Sorts to ascending order
int partition(int input[], int lo, int hi) {
    int pivotIndex = lo;  // Choose the first element to be pivot element. We could make smarter choices 
    int i = lo + 1;       // Left scanner
    int j = hi;           // Right scanner
    while (1) {
        while (input[i] &lt; input[pivotIndex] &amp;&amp; i &lt; j) {  // Pause when an item in the left segment was found to be larger than the pivot value 
            i++;  
        }
        while (input[j] &gt; input[pivotIndex] &amp;&amp; i &lt; j) {  // Pause when an item in the right segment was found to be smaller than the pivot value
            j--;
        }
        if (i == j) break;          // Stop once i and j cross over
        else swap(input, i, j);     // Swap and then resume scanning from where we left off
    }
    j = (input[i] &lt; input[pivotIndex]) ? i : i - 1;  // If where element at where i stopped is smaller than the pivot value, set j to i, otherwise set it to i - 1 
    swap(input, pivotIndex, j);  // Swap the pivot element at input[lo] to where it should be -- at index j where the left scanner and right scanner intersected
    return j;  // The pivot is now at j, where it belongs
}</code></pre><p id="0b759db4-ee7c-44c1-8750-e4ab702c1c4c" class=""><em>Time-Complexity:</em> O(n²) — but the average case is usually better
Best case: the choice of pivot leads to equal partitions for each recursive step, so there will be log(n) levels, each level requiring n comparisons, hence O(nlogn)
Worst case: the choice of pivot leads to paritions of sizes 1 and (n-1) for each recursive step, so there will be n levels, requiring n comparisons, hence O(n²)
Eg. for sorted arrays, we will make n recursive calls, forming 1 and n-1 partitions</p></div><div id="af65d469-6afe-4373-930e-f8b5e8476313" style="width:31.25%" class="column"><p id="306e61fa-35d7-45d1-ab86-e76eb5f12a73" class=""><em>Partitioning steps: </em></p><figure id="c7563e62-cce9-49c9-89a0-f58cc2c38dda" class="image"><a href="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%2015.png"><img style="width:288px" src="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%2015.png"/></a></figure><p id="fd8a8f9d-4341-468a-a076-9640c76a2756" class=""><strong>Improving partition:</strong></p><ul id="06159d89-bd00-4b50-814a-d446ddf1add9" class="bulleted-list"><li>Could select the pivot in other ways instead of taking the first element every recursive step</li></ul><ul id="d7687be8-15fa-4208-82e7-570877814daa" class="bulleted-list"><li>Parititioning is inefficient when dealing with small partitions. We could solve small partitions differently by, for example, switching to insertion sort.</li></ul><ul id="d3b9067e-0898-4acd-a26f-2cc24fe75cf5" class="bulleted-list"><li>If the array contains duplicates of the pivot value, we could 3 partitions with the middle one containing duplicates of pivot. </li></ul><p id="c0b75b55-617d-4652-8eeb-986b8e0ecbd2" class=""><em>Quicksort can be implemented iteratively using a stack:</em></p><pre id="01d5cfa5-c45d-4161-9e0a-2b1af5f323d8" class="code"><code>void quickSort(int input[], int lo, int hi) {
        Stack s = newStack();
        StackPush(s, hi);
        StackPush(s, lo);
        while (StackSize(s) &gt; 0) {
                int low = StackPop(s);
                int high = StackPop(s);
                if (high &gt; low) {
                        int i = partition(input, lo, hi);
                        StackPush(s, hi);
                        StackPush(s, i + 1);
                        StackPush(s, i - 1);
                        StackPush(s, lo);
                }
        }
}</code></pre></div></div><div id="a40d04dd-3bff-44b3-826f-7ab7f5512a95" class="column-list"><div id="e766afbe-27d3-43ec-8361-d76a83728032" style="width:62.5%" class="column"><p id="15072883-bf54-4a8c-9e45-b7b256e26a9d" class=""><strong>Merge sort </strong><strong>(recursive):
</strong><em>Logic:</em><strong> </strong>split the array into two equal partitions, sort each partition, then merge it into a final sorted array. </p><pre id="7cf893e5-5949-47d2-918d-683e6813922c" class="code"><code>// Sorts to ascending order
void mergeSort(int input[], int lo, int hi) {
    if (lo &gt;= hi) return;
    int mid = (lo + hi) / 2;
    mergeSort(input, lo, mid);
    mergeSort(input, mid + 1, hi);
    merge(input, lo, mid, hi);
}

void merge(int a[], int lo, int mid, int hi) {
    int i = lo;
    int j = mid + 1;
    int k = 0;   // Indexer for temporary array
    int tmp[hi - lo + 1];  // Temporary array to store sorted values
    
    while (i &lt;= mid &amp;&amp; j &lt;= hi) {  // Scan through both segments, choosing the one that&#x27;s less than the other
        if (a[i] &lt; a[j])
        tmp[k++] = a[i++];        // Move the index of the left segment along
        else
        tmp[k++] = a[j++];        // Move the index of the right segment along
    }
    
    // One of the segments will still have elements that need to be copied over
    while (i &lt;= mid) tmp[k++] = a[i++];
    while (j &lt;= hi) tmp[k++] = a[j++];

    // Copy the sorted dummy array into the main array
    for (i = lo, k = 0; i &lt;= hi; i++, k++)
        a[i] = tmp[k];
}</code></pre><p id="697b39b3-e954-4522-bcfa-5397295f86fe" class=""><em>Time-complexity</em>: O(nlogn)
Best case: each level requires less than n comparisons when merging — O(nlogn)
Worst case: each level requires comparisons made all the way until the end of partitions — O(nlogn)</p><p id="4db052f2-2581-4c52-8adc-06a77891634c" class=""><em>Space-complexity:</em> O(N)</p><p id="303bb496-15bf-44c7-b1b6-2640a60a9f08" class="">
</p></div><div id="63a541d7-55f2-4b59-ab0e-997d061a8323" style="width:37.5%" class="column"><p id="5cc6b34c-7da6-441d-9627-a23eb097b74d" class="">
</p><p id="c22634b9-1ee3-40d2-8b9a-6391676690d5" class="">
</p><figure id="5f78050a-3b64-4fe1-811a-ca0d9c633189" class="image"><a href="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%2016.png"><img style="width:1040px" src="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%2016.png"/></a></figure><p id="17169bcb-9f5f-4a5c-b592-55f6db5eedd1" class="">
</p><p id="9ecb8a71-4b3b-4651-b957-aa3a44fbd214" class="">
</p><p id="2061f56e-843b-4469-879d-0f5b276bfdb0" class=""><em>Mergesort can be implemented non-recursively, without a stack.  
</em><strong>Bottom-up Mergesort (iterative):</strong></p><pre id="47da3a2e-7f2b-4c6b-b665-72ea45ad5271" class="code"><code>void mergeSort(int a[], int lo, int hi) {
        int end;
        for (int m = 1; m &lt;= lo - hi; m = m * 2) {  // Run lengths are: 1, 2, 4, ... until the run length is greater than the array size
                for (int i = lo; i &lt;= hi - m; i += 2 * m) {
                        end = min(1 + 2 * m - 1, hi);  // End is the endpoint of the two segments (runs). Select end = hi, so we don&#x27;t run over the array size
                        merge(a, i, i + m - 1, end);   // i + m - 1 is the midpoint of the start of the first segment and end of the second
                }
        } 
}</code></pre></div></div><hr id="6e095b0a-3910-45f4-a50d-0fe9efc01f7a"/><div id="5e001bab-f03f-47b9-916e-81a3fdb00aaf" class="column-list"><div id="cc343fa6-510f-4a4f-99d3-403c72c0d30f" style="width:25%" class="column"><p id="d06e5dd6-087e-40a8-97ce-b568d3a517a9" class="">Sorting lower bound of performance: any comparison-based sorting algorithm <em>must take at least Ω(nlogn) time </em>to sort n elements.
<em>Proof. </em>Suppose that we have a sequence of n unique values. There are n! permutations, where one sequence is ordered.  For a binary decision tree, the height is at least log2(n!), so the number of comparisons required is log2(n!), which using inequalities, can be proven to be greater than nlogn. Hence Ω(nlogn) is the lower bound for all comparison based sorting algorithms.</p><p id="c96cd1bd-c8d1-41c0-9992-30d633e219c5" class="">
</p></div><div id="3a43663d-81a1-403f-b803-d36b8177ac4a" style="width:75%" class="column"><figure id="281175a7-9f10-4ab3-b39c-42d722fbe74b" class="image"><a href="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%2017.png"><img style="width:480px" src="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%2017.png"/></a></figure><p id="25bae844-3ded-463b-8b06-edae36e377ca" class="">
</p></div></div><hr id="3919e8d2-c21a-4bb7-8f85-d093b0d40e46"/><p id="a22bc447-253b-4aaa-932e-eb0e783942af" class="">
</p><h3 id="e8737ca4-da54-408d-ba2c-768639a7f041" class="block-color-red_background">Non-Comparison based sorting</h3><p id="0c230327-c6d5-4274-bf2c-9ef1ad65331c" class=""><strong>Radix Sort:
</strong><em>Logic:</em> sort the array by the last digit, then by the next and so on until the largest radix is sorted. At this point, the array is sorted. This works only if the implementation is stable</p><p id="b9cec127-f02f-4624-a354-699581acfc54" class="">
</p><p id="d9b63b08-1118-459b-904d-63e51673d917" class=""><em>Time-complexity:</em> O(mn) — where m is the number of radix points. This generally outperforms comparison based sorting algorithms when n → ∞</p><p id="5a7e6cfb-8fbe-4723-8ded-e301364f22cd" class="">
</p><h1 id="8e6c9907-ad63-4b64-9ad1-ff1ac13a6171" class="block-color-blue_background">Week 9: Text Processing Algorithms</h1><p id="a6e41a7d-dd8b-4c74-a994-4c709b761b57" class=""><strong>Notes:</strong></p><ul id="2570ad70-a303-4134-97c1-5747f9e7a2f2" class="bulleted-list"><li>Alphabet Σ — defines the <em>set of characters </em>usable in strings
Empty string λ — string of length 0, &quot;&quot;</li></ul><ul id="f3e99bb8-6726-4e49-9c19-501efd24c35a" class="bulleted-list"><li>Brute-force pattern matching involves comparing a substring to a chunk of the main text and only moving the chunk along by 1 after each iteration.</li></ul><ul id="ae53c089-0e4e-4479-8739-1c1bdea82fdb" class="bulleted-list"><li>Boyer-Moore&#x27;s and Knuth-Morris-Pratt&#x27;s pattern matching algorithms are like the brute force algorithm but they can compute a smarter jump length for each iteration</li></ul><ul id="c761d86c-06ef-44cd-b743-81ce0584a3b3" class="bulleted-list"><li>Boyer-Moore works well for texts with large alphabets with a reasonable distribution of different characters.
Knuth-Morris-Pratt works well for texts with smaller alphabets (eg. DNA sequences).
Both algorithms aim to shift the text substring forward more intelligently than the brute-force approach</li></ul><p id="36fe593a-c3fd-4b92-b9af-56e119cdc565" class="">
</p><h3 id="ec801f3a-8f8e-4b65-9cff-c52025c6130e" class="block-color-teal_background">Boyer-Moore Algorithm: </h3><div id="dc4137dd-befb-409f-8d72-9815c2f6dd18" class="column-list"><div id="3d8770fb-e5d4-4ad1-8e45-131d15572d02" style="width:50%" class="column"><p id="eac545b1-040b-46ca-b3d1-9fab94a3bff2" class=""><em>Logic:</em> compare the last character of the pattern to the corresponding character in the text. If mismatch, then check if that mismatching character from the text appears in the pattern. If it does, then jump forward a calculated amount. If it doesn&#x27;t then jump by <code>strlen(pattern)</code> characters.</p><p id="ecb7582b-4c24-4169-8bc6-e92c573a60af" class="">The Boyer-Moore algorithm requires some preprocessing using the <em>last occurrence function:</em>  <strong>L : Σ → {0, 1, ..., m}</strong></p><ul id="78ed82d2-2770-4e91-a802-26fd01cc5cca" class="bulleted-list"><li>Consider the string &quot;acab&quot;
L(a) = 2   → Although a also appears at index 0, we only want the last occurrence
L(b) = 3
L(c) = 1
L(d) = -1 → Setting to unused characters to -1 is important in computing the jump distance
... 
L(z) = -1</li></ul><ul id="6ba04216-7857-45a6-889f-7d874516c855" class="bulleted-list"><li>L maps each letter of the alphabet to the index where the character last occurred in the string. So when calculating the last occurrence index, it first has L(a) = 0 and then updates it to L(a) = 2 to record the last occurrence of a.</li></ul><ul id="461e3ec1-a4c1-4695-a7c8-0f3e1fc7becd" class="bulleted-list"><li><em>Time-complexity:</em> O(m+s) — where <code>m</code> is the length of the string and <code>s</code> is the cardinality of the alphabet</li></ul><p id="75a91b10-90b2-4a9c-a1b2-ca76b1ec915b" class="">
</p></div><div id="1f2b0e03-36ef-4bb8-a5e2-06eb6b68d129" style="width:50%" class="column"><p id="d7081645-4eef-487a-8058-0a83e1b4e6cb" class=""><em>Boyer-Moore algorithm:</em></p><pre id="b481af23-4925-4680-aef0-a18925b1e538" class="code"><code>int BoyerMooreMatch(char *text, char *pattern, char *alphabet) {
        int i = m - 1;  // Where m is the length of the pattern
        int j = m - 1;  
        while (i &lt; n) {  // Where n is the length of the text
                if (text[i] == pattern[j]) {
                        if (j == 0) {
                                return i;  // The pattern survived all character matches, so return the index of the main text where the pattern was found
                        } else {
                                i--;  // Decrement to match the next pair of characters
                                j--;
                        }
                } else {
                        i += m - min(j, 1 + L(text[i]));  // If the last occurrence of text[i] is AFTER j, then jump (m - j) characters. Else, if the last occurrence of text[i] is before j, then jump (m - (1 + L(text[i]))) -- This aligns the character in &#x27;pattern&#x27; with text[i]
                        j = m - 1;
                }
        } 
        return NO_RESULTS;
}</code></pre><p id="e7eafa27-a509-44cf-b6f0-73370d7df37e" class=""><em>Time-complexity:</em> O(nm + s)
Worst case: finding pattern &quot;baaa&quot; in &quot;aaaaaaaa...aaa&quot;</p></div></div><div id="da2a8424-fa78-4fc5-9d0c-d4a5b6dcdd86" class="column-list"><div id="c89d31ad-d95a-4599-a206-af6451f718f4" style="width:29.166666666666664%" class="column"><p id="3d5b0adb-973a-4ba7-8bb5-34c3fa54720c" class=""><strong>Case 1:</strong>
<code>text[i]</code> does not occur in the pattern string (so <code>L(text[i])</code> is -1). Jump <code>m - (1 + L(text[i]))</code>, which is the biggest jump possible — <code>m</code> characters</p><figure id="7c2bac45-2ef9-4158-adee-fe09b7daaa87" class="image"><a href="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%2018.png"><img style="width:336px" src="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%2018.png"/></a></figure><p id="c29c4da1-2371-4756-857f-e46f3d8086b0" class="">
</p></div><div id="a6b57d19-ab57-4281-b404-834b1c07a8b6" style="width:25%" class="column"><p id="686f186d-6064-4329-bc61-f63e27fabb60" class=""><strong>Case 2:</strong> 
<code>text[i]</code>&#x27;s last occurrence in pattern is <em>after</em> <code><em>j</em></code>, so jump <code>m - j</code> characters</p><figure id="0410d02d-eff3-446c-85c6-bbb2f8cbfe4e" class="image"><a href="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%2019.png"><img style="width:336px" src="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%2019.png"/></a></figure></div><div id="a6138548-a7e9-4bc5-83be-1a05fe506a83" style="width:45.83333333333335%" class="column"><p id="76eb166b-44e3-463c-82cd-19528d74c1cb" class=""><strong>Case 3:</strong> 
<code>text[i]</code>&#x27;s last occurrence in pattern is <em>before</em> <code>j</code>, so jump <code>m - (1 + L(text[i]))</code> characters
The mismatched <code>text[i]</code> is aligned with the same character found before <code>j</code> in the pattern</p><figure id="8f15b005-8ddb-4b11-b5eb-e149e0d210fe" class="image"><a href="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%2020.png"><img style="width:336px" src="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%2020.png"/></a></figure><p id="f2b14113-7006-4b7d-9d5a-114f9adea459" class="">
</p></div></div><p id="069e0f37-aa38-4653-81b6-3425745e7a8f" class="">
</p><h3 id="2493184c-3cad-4736-91cf-495cb82875cb" class="block-color-teal_background">Knuth-Morris-Pratt Algorithm:</h3><div id="939958eb-5cb0-4251-aafc-579facc70b8f" class="column-list"><div id="fb3e40b9-eb3a-4533-ad49-eb4a01ac8a63" style="width:33.333333333333336%" class="column"><p id="bec72bd0-8304-42e1-8a7c-4a32244e27a4" class=""><strong>Failure function: 
</strong>KMP also requires preprocessing on the pattern to find if prefixes occur in the rest of the pattern.</p><p id="469d5597-7b85-4099-9f17-36083da9d716" class="">For each index <code>j</code>, find the longest prefix from 0 to <code>j</code> that matches the suffix in [1, j], up to and including index j, then record the function value as the number of characters in the prefix.</p><figure id="f79076e8-bbad-413b-ade4-52f1188377eb" class="image"><a href="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%2021.png"><img style="width:192px" src="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%2021.png"/></a></figure><p id="9036557f-1ab4-4bf5-84dc-ca4ad40209ce" class="">For j = 0: &quot;a&quot;           — no prefix matches suffix — record F(0) = 0
For j = 1: &quot;ab&quot;         — no prefix matches suffix — record F(1) = 0
For j = 2: &quot;aba&quot;       — &quot;a&quot; works                        — record F(2) = 1
For j = 3: &quot;abaa&quot;     — &quot;a&quot; works                        — record F(3) = 1
For j = 4: &quot;abaab&quot;   — &quot;ab&quot; works                      — record F(4) = 2
For j = 5: &quot;abaaba&quot; — &quot;aba&quot; works                    — record F(5) = 3</p><p id="1140ac41-dd3d-4183-a517-cf589be8e9eb" class=""><em>Time-complexity:</em> O(m)</p><p id="ad1457df-8442-4a3e-9e11-0dda5049f5d3" class="">
</p></div><div id="15eb442a-2fa1-4f61-8005-716c0f52c244" style="width:45.83333333333333%" class="column"><p id="ad8fc5c4-63b5-4a94-80c7-257716a5de3b" class=""><em>Knuth-Morris-Pratt algorithm:</em>
KMP scans from left to right, unlike Boyer-Moore.</p><pre id="368d87b2-3c17-4736-a10c-e542406c5e29" class="code"><code>int KMPMatch(char *text, char *pattern) {
        int i = 0;  // Start scans from left to right
        int j = 0;
        int F[m];
        failure(F, m);  // Fill up array F with function values
        while (i &lt; n)) {  // Where n = strlen(text)
                if (text[i] == pattern[j]) {
                        if (j == m - 1) {
                                return (i - j);  // Pattern found, return the index at the start of the successful match
                        } else {
                                i++;
                                j++;
                        }
                } else {  
                        if (j &gt; 0) {
                                j = F[j - 1];  // On failure, resume comparing the pattern starting from F(j - 1)
                        } else { 
                                i++;
                        }
                }
        }
        return NO_MATCHES
}</code></pre><p id="6182a68c-4bc2-4973-bb05-83138447112b" class=""><em>Time-complexity:</em> O(m + n) — O(m) for the failure function preprocessing and O(n) for scanning through the whole text</p></div><div id="12edeba5-0a58-496d-bd93-26b8c95e75d6" style="width:20.833333333333343%" class="column"><p id="86628b63-c4be-45d8-aff5-c32d592b972d" class="">On mismatch, reset <code>j</code> to <code>F(j - 1)</code> if <code>j &gt; 0</code> and continue scanning. If <code>j == 0</code>, then just increment <code>i</code> and continue scanning</p><figure id="96195425-847d-4966-b266-c4c65d5183d0" class="image"><a href="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%2022.png"><img style="width:384px" src="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%2022.png"/></a></figure><p id="d63ca45b-489f-4317-8d68-de47939faf31" class="">
</p></div></div><h3 id="61787c18-0b5f-4174-8ad8-3f5af42d75a7" class="block-color-teal_background">Tries:</h3><div id="503bb5a1-f357-4b7a-a42c-36dae4e82c9f" class="column-list"><div id="342dc38a-95cc-4293-bb44-2d78189c4506" style="width:50%" class="column"><p id="dca0f8f2-5383-4eaa-b655-0faf8840f127" class="">A <em>trie </em>is a tree which holds a <em>set of strings</em>, like all the words in a text or a dictionary, and handles two main operations: <code>search()</code> and <code>insert()</code>. Trie&#x27;s name comes from re<em>trie</em>val. </p><p id="a3febae6-6c51-4b74-b0a2-8addcbaf92cf" class="">Boyer-Moore and Knuth-Morris-Pratt&#x27;s algorithms preprocessed their <em>pattern </em>string. If the text is large, immutable and searched for often, like <em>Hamlet</em>, then we can preprocess the <em>main </em>text instead, allowing for quick pattern queries using the trie data structure.</p><p id="fb1de908-ccac-4a9d-91c5-a87c9fd32f51" class="">
</p><p id="b35b2be3-7937-416e-a612-2e169e3bdefe" class="">The depth of a tree is equal to the longest string length. </p><p id="f26e0833-0ba8-4ab5-8348-390582b93928" class="">
</p><p id="e321a9af-aa3d-477f-b6bc-7149c6ecfa92" class="">Each node:</p><ul id="cd52b1a4-317f-4f2b-ba9f-6c7f6a19a034" class="bulleted-list"><li>Contains just one character</li></ul><ul id="5fc4636d-14d9-44dc-a763-3d54d3d16d61" class="bulleted-list"><li>Has 0-26 children</li></ul><ul id="b5127b3a-8090-45c8-8439-76dfa05cbb3f" class="bulleted-list"><li>May be marked as a terminating node (but can still have children) to identify that the node is the end of a complete recorded word</li></ul><ul id="6cc76d4c-8440-4a15-82a1-627af7c747cc" class="bulleted-list"><li>Terminating nodes may also hold the line numbers/index of the word&#x27;s occurrences in the text as a struct field</li></ul><p id="990de974-3ecd-48c2-a02b-129170b21d17" class="">The number of words stored = the number of terminating nodes</p><p id="3265402b-3905-47ff-97e7-cd6de9a80573" class="">
</p></div><div id="72db9a32-0366-455c-a6df-970a0eb3142e" style="width:50%" class="column"><p id="73d9dbd9-869e-45de-ac25-1f8229e47ea3" class=""><em>Possible struct declaration:</em></p><pre id="fe9ece2a-1e9b-4208-a5be-527be5ea93fe" class="code"><code>#define ALPHABET_SIZE 26
typedef struct trieNode *Trie;
struct trieNode {
        bool isLastChar;  // If this is true, then a complete word has been formed when this node is reached
        char character;   // Current node&#x27;s character
        Trie *children;   // An array of size ALPHABET_SIZE    
};

// Returns a pointer to the node where the target string was found
Trie findInTrie(Trie trie, char *target) {
        char *ch;
        Trie curr = trie;
        for (ch = target; ch != &#x27;\0&#x27;; ch++) {		
                if (curr -&gt; children[ch]) {
                        curr = curr -&gt; children[ch];  // Move down the trie, following the target string&#x27;s characters
                } else {
                        return NULL;  // Character node doesn&#x27;t exist
                }
        }
        if (curr -&gt; isLastNode == true) {
                return curr;
        } else {
                return NULL;  // Character was found, but it wasn&#x27;t marked as a finishing node. So the word wasn&#x27;t actually recorded
        }
}

// Not sure if this works... 
Trie insert(Trie trie, char *newWord, int length) {
        Trie t;
        if (trie == NULL) {
                t = malloc(sizeof(struct trieNode));
                t -&gt; character = newWord[0];
        }
        if (m == 0) {
                t -&gt; finish = true;
                t -&gt; data = newWord;
        } else {
                t -&gt; children[newWord[1]] = insert(trie, &amp;newWord[1], length - 1);  // Pass a string one character shorter to the next insert() call
        }
        return t;		
}</code></pre><p id="24ab423d-6850-4975-adb2-30cacfb7de6a" class=""><em>Time-complexity:</em> O(sm) — where m is strlen(target string) and s is the size of the alphabet. The time-complexity is independent of how many actual entries there are in the tree.
<em>Space-complexity:</em> O(n) — size of text (eg. total number of characters in each word in a dictionary)</p></div></div><hr id="04f17f98-44bc-4307-9dab-9b70324ffec1"/><h3 id="fe2da8bd-2a4c-4606-a0e2-2103c4d31a39" class="block-color-teal_background">Compressed Tries:</h3><div id="1e6673d9-8fc3-4805-b40b-4f7af18df473" class="column-list"><div id="4f37e4d1-1a36-4dac-acf7-a272624c7ba2" style="width:25%" class="column"><p id="74ceb6be-e1d2-4a0a-8ff0-65ac6fd9fd8e" class="">Compressing a trie involves <strong>c</strong>ollapsing linear branches into a single node:</p><figure id="28a21462-6bf8-496c-880a-9368bf4a6ecb" class="image"><a href="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%2023.png"><img style="width:336px" src="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%2023.png"/></a></figure></div><div id="2b17e947-1df7-41cc-8c94-11126763cad9" style="width:75%" class="column"><p id="74406baa-8dea-4b61-a470-d1d729e99e08" class="">Using 3-tuples, (i, j, k), we can encode a slice of strings for collapsed linear branches. 
So (8, 2, 3) navigates to the 8th word and then takes the slice of S[8] from index 2 to 3</p><figure id="efd2631f-4a19-4cd6-8ac9-8d785db74868" class="image"><a href="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%2024.png"><img style="width:528px" src="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%2024.png"/></a></figure></div></div><p id="475ec0b0-13e9-4f32-a36e-d8168ed42c0f" class=""><strong>Compressed Suffix Tries — For pattern matching:</strong></p><p id="8eb20b6c-3301-4b9e-8d0b-f27454a1fe92" class="">Insert all suffixes of a given word as separate entries into a trie and then compress it.</p><p id="67d90c48-ee2c-441f-b903-b3e4c427c69a" class="">For example, for &quot;minimize&quot;:
Insert all suffixes: &quot;e&quot;, &quot;ze&quot;, &quot;ize&quot;, ..., &quot;minimize&quot; into a regular trie, then compress.</p><div id="8f526dc0-9e9a-47fb-bd0c-f5bda00b9bbf" class="column-list"><div id="a4cec494-e870-4640-a9e9-2f6cce02abdb" style="width:25%" class="column"><figure id="c8247c4e-dd62-44b2-8731-8a874972741c" class="image"><a href="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%2025.png"><img style="width:384px" src="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%2025.png"/></a></figure></div><div id="139c1b43-e8fe-47ae-9373-af2c16547d16" style="width:75%" class="column"><p id="be517b16-4526-4e56-874e-1eb76e0f369f" class="">2-tuples representing slices of the text, &quot;minimize&quot;</p><figure id="3c993d29-58fe-4207-8f0b-85221632a782" class="image"><a href="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%2026.png"><img style="width:432px" src="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%2026.png"/></a></figure></div></div><p id="c1320052-909a-4b2d-abae-1a0fe2f012a1" class=""><em>For constructing the suffice tree:</em>
<em>Time-complexity</em>: O(n) — 
<em>Space-complexity</em>: O(n) — </p><p id="4444c694-5710-4c8c-9bfc-82a594dedbb6" class="">Pattern matching:
<em>Time-complexity: </em>O(ms) — where m is the length of the pattern and s is the size of the alphabet</p><p id="ecff631a-8bf1-4cdc-b409-868ced8efd85" class="">
</p><h3 id="bf7e854a-b8fc-4dbb-8500-123ab1304d5b" class="block-color-teal_background"><strong>Text Compression — Huffman&#x27;s Algorithm:</strong></h3><p id="fff92529-37db-4ee0-af60-feda58e1cd9b" class="">Text compression revolves around the problem: <em>&quot;can we efficiently encode a string X with a smaller string Y?&quot;</em></p><p id="9223d5c0-594d-47a2-a6e2-46459057caee" class="">Lossy compression: a class of <em>irreversible </em>data compression methods using approximations and partial data discarding to represent the content, causing a loss of quality/resolution.</p><ul id="c9f5922c-cc0c-4a9b-936d-a4f95b1bb8a7" class="bulleted-list"><li>For MP3, there are certain frequencies that aren&#x27;t human detectable so we can remove the bits encoding those frequencies</li></ul><ul id="00bfea88-32c6-4371-85c3-2ea005075b37" class="bulleted-list"><li>JPG is a lossy compression method for digital images. We can reduce the colour encoding size — meaning that for heavier compressions, the difference between colours is less fine because the colour encoding capability is made smaller since we&#x27;ve reduced the amount of bits available to encode each pixel&#x27;s colour</li></ul><p id="29842294-4e31-4cf3-a228-ac5d03fc2d67" class="">
</p><div id="553f136f-e4f4-4542-9d78-facfc80da286" class="column-list"><div id="3f1a37cf-4614-4041-8412-7ac9c3c71bff" style="width:33.333333333333336%" class="column"><p id="5d39e072-9886-4798-9df2-66c98d89468e" class=""><strong>Huffman&#x27;s algorithm:
</strong>Huffman&#x27;s algorithm provides a <em>lossless </em>text compression system. It defines bit-codes for characters such that each bit code is <em>not a prefix for any other bit code</em>, which is crucial for navigating the Huffman encoding tree.
Higher frequency characters are assigned shorter bit codes.</p><ol id="a0951123-8d1c-42d4-8a89-2d24e2044c8a" class="numbered-list" start="1"><li>Go through entire text and calculate the frequency of every character</li></ol><ol id="7b2bfd2a-0ac0-4d6b-86da-eb5100a30f8c" class="numbered-list" start="2"><li> Build the encoding tree:
→ Initially have single nodes representing each character in the text
→ Merge the two lowest frequency characters into a single cluster
→ Repeat the process until a full tree is created<figure id="2e71336a-4f19-4800-9f46-83f31aec50b2" class="image"><a href="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%2027.png"><img style="width:432px" src="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%2027.png"/></a></figure></li></ol></div><div id="b9f0cdd5-e6f8-4ab2-976b-a72cc1596c4b" style="width:16.666666666666664%" class="column"><p id="e0051915-9c22-48bf-b419-6b8ce630c2bb" class="">The path to a leaf node corresponds to a bit-code</p><figure id="f79101d1-51a8-4640-93fe-2d2333a0637b" class="image"><a href="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%2028.png"><img style="width:288px" src="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%2028.png"/></a></figure></div><div id="410994c2-9b3f-4be1-b3e8-91db6c6bcd51" style="width:50.000000000000014%" class="column"><pre id="4f4564a0-84b3-4aae-8c09-4514ea94b290" class="code"><code>Tree createTree(char *text) {
        int frequencies[ALPHABET_SIZE];
        computeFrequencies(frequencies, text); 
        PQueue pqueue = newPQueue();
        for (char c = &#x27;a&#x27;; c &lt;= &#x27;z&#x27;; c++) {
                if (frequencies[c] != 0) {
                        Tree t = malloc(sizeof(struct treeNode));
                        t -&gt; freq = frequencies[c];
                        t -&gt; left = NULL;
                        t -&gt; right = NULL;
                        PQueueJoin(queue, t);
                }
        }
        while (QueueSize(queue) &gt;= 2) {
                t1 = PQueueLeave(queue);  // t1 has highest priority (frequency)
                t2 = PQueueLeave(queue);  // t2 has next highest priority
                freq1 = t1 -&gt; freq;
                freq2 = t2 -&gt; freq;
                Tree t = malloc(sizeof(struct treeNode));  // Create a new tree which has t1 and t2 as subtrees and contains the sum of both their frequencies
                t -&gt; freq = freq1 + freq2;
                t -&gt; left = t1;
                t -&gt; right = t2;
                PQJoin(queue, t);  // Join this tree into the queue of nodes to join
        }
        return PQLeave(queue);  // There should be last element left in the queue, which is the root node of a completed encoding tree
}</code></pre><p id="2fc3eb2d-df0e-41cf-8964-110a666d96c1" class=""><em>Time-complexity:</em> O(n + slogs) — for computing frequencies, creating nodes for each occurring character and building the encoding tree, where s is number of unique characters</p></div></div><p id="367589eb-9b9b-4c78-bf71-2a1df5937ce3" class="">
</p><p id="035b416e-46f8-4a5b-a74a-ceb7d04d9080" class="">
</p><hr id="bfd1ebba-0c3e-4a25-93f1-c2a78d56c081"/><h2 id="aeed0b6e-1dd7-4951-b291-7fa170fea677" class="block-color-teal_background">C Extras: </h2><ul id="44ca9f4d-46a6-4b93-bcf9-617ac12bb4c0" class="bulleted-list"><li><strong>Switch-case statements:</strong>
A nicer alternative to a series of <em>else if</em> statements<pre id="0fbb6350-683c-4eef-b758-02fa1cbebf12" class="code"><code>switch (expression) { // The expression is evaluated and compared with each case{
    case constant1:   // This block is executed if expression resolves to constant1
        // statements
        break;          // Breaks out of the curly brackets
    case constant2:
        // statements
        break;
    ...
    default:          // Optional. This block is executed when no cases were matched
        // default statements
}</code></pre></li></ul><ul id="29e2dc23-fe51-4a4b-b35d-499dcd8171aa" class="bulleted-list"><li><strong>Ternary conditional operators:</strong> 
Resolves to one value if the condition is true, or resolves to another if the condition is false:<pre id="8413dbdc-bb23-47d1-a329-58a9b928b1ca" class="code"><code>int x = 1, y;
y = (x == 1 ? 0 : 1);  // Assigns y to be 0, since x == 1 is true. Syntax: y = (condition ? trueValue : falseValue)</code></pre></li></ul><h3 id="9166c833-6fdc-4243-b74e-e092781e75b0" class="">Compilation and Makefiles:</h3><p id="47cc4942-4453-46c2-8ca2-13934cec1d47" class="">The separation between .h and .c files is crucial and will be used extensively in implementing abstract data types</p><ul id="e5e2e415-6d28-42cf-b311-47265a525b58" class="bulleted-list"><li>Compilers are <em>programs </em>that convert source code to executable machine code
gcc — Gnu C compiler, a multi-purpose tool that compiles (-c), links and produces executables (-o)</li></ul><ul id="65d5e1f6-afaa-47f1-87fe-c5836b6841b1" class="bulleted-list"><li><strong>Compilation steps:</strong>
1. Preprocessing phase — for preprocessor directives like #define, the compiler replaces all macros with their associated value
2. Compiles source code to produce <em>object files</em> 
3. Object files and libraries are linked to produce the final executable file</li></ul><div id="e67e81d6-bf7a-4a27-b60a-c47cac4bed6d" class="column-list"><div id="ca5cd037-ee56-4aaa-96bf-b9fbf1c1eac0" style="width:31.25%" class="column"><figure id="4077e463-99c7-49e2-942a-9693c697d53a" class="image"><a href="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%2029.png"><img style="width:384px" src="COMP2521%20-%20Data%20Structures%20and%20Algorithms%204a565ff3c09b448faf2da42cbfeee177/Untitled%2029.png"/></a></figure></div><div id="1e0a5920-b75e-4d94-8a76-12241748b03f" style="width:68.75%" class="column"><pre id="3c0931e6-dada-4ea5-8d5b-82252fa0f2e7" class="code"><code>gcc -c Stack.c                # Produces Stack.o from Stack.c and Stack.h
gcc -c bracket.c              # Produces bracket.o from bracket.c and bracket.h
gcc -o rbt bracket.o Stack.o  # Links bracket.o, Stack.o and libraries and produce the executable named &#x27;rbt&#x27;
                                                            # If the executable name isn&#x27;t specified then by default the name is a.out 
                                                            # The libraries are included implicitly</code></pre></div></div><ul id="20cb505b-c1e6-40d9-a6f8-a0ac8e38ce2c" class="bulleted-list"><li><strong>Include directive:</strong>
The #include preprocessor directive is used to paste code into the current flower.
<code>#include &lt;stdio.h&gt;</code> — the <code>&lt;&gt;</code> tells the compiler to search for header files in the System Libraries
<code>#include &quot;myfile.h&quot;</code>  — the <code>&quot;&quot;</code> tells the compiler to search for header files in the current directory
Header files vs .c file is like the interface vs. implementation</li></ul><ul id="d49c9807-3b83-42da-a1bc-e3bb7dd64c63" class="bulleted-list"><li><code>#include</code> preprocessor directive is used to paste code of given file into current file.</li></ul><ul id="ff03553f-3a55-48b8-ab33-ebecba3c141b" class="bulleted-list"><li><strong>For example #include &lt;stdio.h&gt;</strong> : These directives tell the c processor to get stdio.h from System Libraries and add the text to the current source file.</li></ul><p id="57a12fb4-4978-40c5-8497-c1913fd5f327" class="">
</p><p id="87774f4e-3e2d-4cb0-9515-dc4ac7f158d5" class=""><strong>Makefile:
</strong>Allows us to see <em>dependencies</em> in our code and conveniently compile using the <code>make</code> command</p><pre id="2f3f098b-7be1-478c-aa55-ab792855e170" class="code"><code>target : source1 source2 …  
        commands to build target from sources

# Example:
game : main.o graphics.o world.o # These sourcese are dependencies
                gcc -o game main.o graphics.o world.o</code></pre><h3 id="6c08d869-a7aa-4fc4-97b1-bd57fa710740" class="">Function Pointers:</h3><p id="bb6e3498-9f1b-44ab-88ba-c7e66702a476" class="">Function pointers are the memory address of functions.
Function pointer declaration: <code>int (*fp) (int)</code> —   fp points to a function that returns an int and has one argument of type int</p><pre id="c6853866-fd3b-4d1e-86fc-f70c07690a68" class="code"><code>int square(int x) { 
        return x * x;
}
int timesTwo(int x) {
        return x * 2;
}

int (*funcPointer) (int);
fp = &amp;square;       // fp points to the square function
int n = (*fp)(10);  // calls square(10)
fp = timesTwo;      // &amp; is optional, fp now points to timesTwo
n = (*fp)(2);       // calls timesTwo(2)
n = fp(2);          // (*...) is optional, normal function call</code></pre><p id="62e75a58-a470-4efc-9c76-25d633e819f4" class=""><em>Higher-order functions:</em> functions that has function pointers as arguments or returns function pointers</p><div id="4ed543ff-3b65-4034-8840-f60af86fb3a9" class="column-list"><div id="f64b955a-7426-41c8-9adf-6c81ef0044a9" style="width:50%" class="column"><pre id="e8ab71ec-fc80-42d4-a4cd-c46bee9cf922" class="code"><code>void traverse (List head, void (*fp) (List)) {
        List curr = head;
        while (curr != NULL) {
                fp(curr);  // Applies the given function to curr! Traverse can apply any to all nodes any function with the signature void *funcName (List) 
                curr = curr -&gt; next;
        }
} </code></pre></div><div id="e87b9806-59a8-460e-abdf-8e48c44bb65d" style="width:50%" class="column"><pre id="069f23f2-be50-45b6-b7db-f0216aa875c3" class="code"><code>void printName (List head);
void printZID (List head);
...
traverse(studentList, printName);   // Where printName fills the parameter: void (*fp) (List)
traverse(studentList, printZID);    // Where printZID fills the parameter: void (*fp) (List)</code></pre></div></div><h3 id="c514b580-49e4-44b8-97d0-e785813f9a25" class="">Generic Types:</h3><p id="de857961-cfeb-4464-b970-665392b830ac" class=""><strong>Polymorphism: </strong>ability of the same code to operate on different data types</p><ul id="ac4258fa-aee8-4326-a0a0-033d2da05ca0" class="bulleted-list"><li><strong>Parametric polymorphism:</strong> generic function parameters — a function argument that can accept multiple data types</li></ul><ul id="78556519-4662-470d-b7c3-dd169057ee5f" class="bulleted-list"><li><strong>Subtype polymorphism:</strong> associated with inheritance hierarchies</li></ul><p id="051b1fda-e4eb-4623-ba60-abf67a59157d" class="">void * pointers allow generic data types. By declaring values of type void *, we could pass those values into functions which <em>downcast </em>the void pointers to the correct type before operating on them. In object-oriented programming, <em>downcasting </em>or type refinement is the act of casting a reference of a base class to one of its derived classes.</p><p id="292a2d15-de2f-4bb0-8b30-d9f234d6b6f7" class="">
</p><hr id="991dce92-4d89-4a4a-a409-33953e1f7f0b"/><p id="7313affa-4ab0-471f-b7f8-db4303b118f5" class="">
</p><p id="f9f2be80-960a-4c4e-8642-34620e82ac1f" class="">
</p><p id="0997f061-6d57-492e-90e3-059962d73095" class="">
</p><p id="27dbc7d0-73ec-42a7-bc11-b32b33d1611d" class="">
</p><p id="e2ca20de-caac-400e-aee3-8b91116ad862" class="">
</p><p id="608f3304-9e57-4a90-91fe-27bdf2240831" class="">
</p><p id="45032dc6-a983-4148-b48d-f5421a444814" class="">
</p><figure id="56edf61b-f518-46b8-b8a9-f1a011536aa6" class="link-to-page"><a href="https://www.notion.so/GDB-56edf61bf51846b8b8a9f1a011536aa6"><span class="icon">🐜</span>GDB</a></figure></div></article></body></html>